<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PARAGON ANALYTICS</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body {
  background: radial-gradient(circle at top, #14002a, #050012);
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
}
button, select {
  padding: 10px;
  margin: 5px;
  border-radius: 6px;
  border: none;
  font-weight: bold;
}
.primary { background: gold; color:black; }
.secondary { background: #333; color:white; }
.panel { max-width:1200px; margin:auto; padding:10px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(170px,1fr)); gap:10px; }
.card { background:rgba(255,255,255,0.08); padding:12px; border-radius:10px; }
.value { font-size:18px; font-weight:bold; }
canvas { background:rgba(255,255,255,0.05); border-radius:10px; margin-top:15px; }
textarea { width:96%; height:200px; border-radius:8px; padding:8px; }
.badge { padding:8px; border-radius:8px; font-weight:bold; cursor:pointer; }
.good { background:#2ecc71; color:black; }
.warn { background:#f1c40f; color:black; }
.bad { background:#e74c3c; color:white; }
</style>
</head>

<body>

<h2>PARAGON ANALYTICS</h2>
<p>Autonomous Business Intelligence Engine</p>

<input type="file" id="csvFile"><br>

<select id="columnSelect">
  <option value="8">Revenue</option>
  <option value="10">Profit</option>
  <option value="9">Cost</option>
  <option value="5">Units Sold</option>
</select>

<select id="aggregationSelect">
  <option value="raw">Raw</option>
  <option value="month" selected>Monthly</option>
  <option value="quarter">Quarterly</option>
</select>

<br>
<button class="primary" onclick="loadCSV()">Load CSV</button>
<button class="secondary" onclick="runAnalytics()">Run Intelligence</button>
<button class="secondary" onclick="exportPDF()">Export PDF</button>

<div class="panel">
<canvas id="lineChart"></canvas>
<canvas id="kpiChart"></canvas>
<canvas id="productChart"></canvas>

<h3>Forecast Accuracy Dashboard</h3>
<div class="grid" id="accuracyPanel"></div>

<h3>Risk & Intelligence</h3>
<div class="grid" id="riskPanel"></div>

<h3>Scenario Forecast</h3>
<div class="grid" id="scenarioPanel"></div>

<h3>AI Explanation Strategy</h3>
<textarea id="aiText"></textarea>
</div>

<script>
let rawData=[], charts={}, cache={};

/* ---------------- LOAD CSV ---------------- */

function loadCSV(){
  const file = csvFile.files[0];
  if(!file) return alert("Upload CSV first.");
  const reader = new FileReader();
  reader.onload = e => {
    rawData = e.target.result.trim().split("\n").slice(1).map(r=>r.split(","));
    alert("CSV Loaded Successfully");
  };
  reader.readAsText(file);
}

/* ---------------- MAIN ---------------- */

function runAnalytics(){
  if(!rawData.length) return alert("Load CSV first.");

  const col = parseInt(columnSelect.value);

  const parsed = rawData.map(r=>({
    date: new Date(r[0]),
    value: parseFloat(r[col]),
    product: r[4]
  })).filter(r=>isFinite(r.value) && !isNaN(r.date));

  const aggregated = aggregateData(parsed);
  let values = clampOutliers(aggregated.map(r=>r.value));
  let labels = aggregated.map(r=>r.label);

  const smooth = expSmooth(values,0.35);
  const forecast = buildForecast(values);

  const mape = backtestMAPE(values,smooth);
  const seasonality = detectSeasonality(parsed);
  const anomalies = detectAnomalies(values);
  const confidence = computeConfidence(values,mape,seasonality,anomalies);
  const validation = automatedValidation(confidence,mape);

  const kpi = kpiCalc(values);
  const risk = riskModel(values,confidence);
  const segments = segment(parsed.map(r=>r.product), parsed.map(r=>r.value));
  const scenarios = scenarioForecast(forecast);

  cache = {confidence,mape,seasonality,anomalies,validation,kpi,risk,scenarios,segments};

  renderLine(labels,values,smooth,forecast);
  renderBars(kpi,segments);
  renderAccuracy(confidence,mape,validation);
  renderRisk(risk);
  renderScenarios(scenarios);
  renderExplanation();
}

/* ---------------- DATA ---------------- */

function aggregateData(data){
  let map={};
  data.forEach(d=>{
    let k = d.date.getFullYear()+"-"+(d.date.getMonth()+1);
    map[k]=(map[k]||0)+d.value;
  });
  return Object.entries(map).map(([k,v])=>({label:k,value:v}));
}

function clampOutliers(d){
  let m=mean(d), s=std(d);
  return d.map(v=>Math.min(m+2.5*s,Math.max(m-2.5*s,v)));
}

/* ---------------- FORECAST ---------------- */

function expSmooth(d,a){
  let s=[d[0]];
  for(let i=1;i<d.length;i++) s.push(a*d[i]+(1-a)*s[i-1]);
  return s;
}

function buildForecast(values){
  let last = values.at(-1);
  let lookback = Math.min(4, values.length-1);
  let trend = (values.at(-1) - values.at(-lookback)) / lookback;
  let vol = std(values)*0.25;

  let base=[1,2,3].map(i=>Math.round(last + trend*i));
  return {
    base,
    upper: base.map(v=>Math.round(v+vol)),
    lower: base.map(v=>Math.round(v-vol))
  };
}

/* ---------------- METRICS ---------------- */

function backtestMAPE(actual,smooth){
  let e=[];
  for(let i=1;i<actual.length;i++){
    if(actual[i]!==0) e.push(Math.abs((actual[i]-smooth[i-1])/actual[i]));
  }
  return mean(e)*100;
}

function detectSeasonality(data){
  let m={};
  data.forEach(d=>m[d.date.getMonth()]=(m[d.date.getMonth()]||0)+d.value);
  return (std(Object.values(m))/mean(Object.values(m)))*100;
}

function detectAnomalies(d){
  let m=mean(d), s=std(d);
  return d.filter(v=>Math.abs(v-m)>3*s).length;
}

/* ---------------- CONFIDENCE ENGINE ---------------- */

function computeConfidence(values, mape, seasonality, anomalies){
  let n = values.length;
  let volatility = (std(values)/mean(values))*100;

  let stabilityScore = Math.max(40, 100 - volatility*1.1);
  let errorScore     = Math.max(45, 100 - mape*1.0);
  let seasonScore    = Math.min(100, seasonality * 2.5);
  let depthScore     = Math.min(100, n * 6);
  let anomalyScore   = anomalies === 0 ? 100 : 70;

  let confidence =
      stabilityScore * 0.30 +
      errorScore     * 0.25 +
      seasonScore    * 0.15 +
      depthScore     * 0.15 +
      anomalyScore   * 0.15;

  confidence = Math.max(55, Math.min(95, confidence));
  return confidence;
}

/* ---------------- RISK MODEL ---------------- */

function riskModel(d, conf){
  let vol = (std(d)/mean(d))*100;
  let riskScore = vol*0.5 + (100-conf)*0.5;

  let level =
      riskScore > 60 ? "HIGH" :
      riskScore > 40 ? "MEDIUM" :
      "LOW";

  return {
    volatility: vol.toFixed(1),
    level
  };
}

/* ---------------- VALIDATION ---------------- */

function automatedValidation(conf,error){
  if(conf > 70 && error < 35) return "VALIDATED";
  if(conf > 55 && error < 50) return "MONITOR";
  return "UNSTABLE";
}

/* ---------------- KPI ---------------- */

function kpiCalc(d){
  return {
    max:Math.max(...d),
    min:Math.min(...d),
    avg:Math.round(mean(d)),
    growth:(((d.at(-1)-d[0])/d[0])*100).toFixed(1)
  };
}

function segment(p,v){
  let map={};
  p.forEach((x,i)=>map[x]=(map[x]||0)+v[i]);
  return Object.entries(map).sort((a,b)=>b[1]-a[1]);
}

function scenarioForecast(f){
  return {
    base:f.base,
    optimistic:f.base.map(v=>Math.round(v*1.12)),
    conservative:f.base.map(v=>Math.round(v*0.88))
  };
}

/* ---------------- UI ---------------- */

function renderLine(labels,actual,smooth,f){
  destroy("line");
  charts.line=new Chart(lineChart,{
    type:"line",
    data:{
      labels:[...labels,"F1","F2","F3"],
      datasets:[
        {label:"Actual",data:actual,borderWidth:2},
        {label:"Smoothed",data:smooth,borderDash:[5,5]},
        {label:"Forecast",data:[...Array(actual.length).fill(null),...f.base],borderDash:[3,3]},
        {label:"Upper",data:[...Array(actual.length).fill(null),...f.upper],borderDash:[2,4]},
        {label:"Lower",data:[...Array(actual.length).fill(null),...f.lower],borderDash:[2,4]}
      ]
    }
  });
}

function renderBars(kpi,segments){
  destroy("kpi"); destroy("prod");
  charts.kpi=new Chart(kpiChart,{type:"bar",data:{labels:["Max","Min","Avg","Growth%"],datasets:[{data:[kpi.max,kpi.min,kpi.avg,kpi.growth]}]}});
  charts.prod=new Chart(productChart,{type:"bar",data:{labels:segments.map(s=>s[0]),datasets:[{data:segments.map(s=>s[1])}]}});
}

function renderAccuracy(conf,error,validation){
  let cls = validation==="VALIDATED"?"good":validation==="MONITOR"?"warn":"bad";
  accuracyPanel.innerHTML=`
  <div class="card">Confidence<div class="value">${conf.toFixed(1)}%</div></div>
  <div class="card">MAPE<div class="value">${error.toFixed(1)}%</div></div>
  <div class="card">Validation<div class="badge ${cls}">${validation}</div></div>`;
}

function renderRisk(r){
  riskPanel.innerHTML=`
  <div class="card">Volatility<div class="value">${r.volatility}%</div></div>
  <div class="card">Risk Level<div class="value">${r.level}</div></div>`;
}

function renderScenarios(s){
  scenarioPanel.innerHTML=`
  <div class="card">Base<div class="value">${s.base.join(", ")}</div></div>
  <div class="card">Optimistic<div class="value">${s.optimistic.join(", ")}</div></div>
  <div class="card">Conservative<div class="value">${s.conservative.join(", ")}</div></div>`;
}

function renderExplanation(){
  aiText.value =
`SYSTEM EXPLANATION

Confidence reflects reliability after correcting volatility and forecast error.
Validation summarizes system health automatically.
Risk blends volatility with confidence.

STRATEGY
- VALIDATED → Safe to scale.
- MONITOR → Observe trends before scaling.
- UNSTABLE → Improve data quality.`;
}

function destroy(n){ if(charts[n]) charts[n].destroy(); }

/* ---------------- ⭐ PROFESSIONAL PDF EXPORT ---------------- */

async function exportPDF(){
  const {jsPDF}=window.jspdf;
  const pdf=new jsPDF("p","mm","a4");
  let y=12;

  pdf.setFontSize(18);
  pdf.text("PARAGON ANALYTICS REPORT",10,y);
  y+=10;

  pdf.setFontSize(11);
  pdf.text(`Confidence: ${cache.confidence.toFixed(1)}%   Validation: ${cache.validation}`,10,y);
  y+=6;
  pdf.text(`Volatility: ${cache.risk.volatility}%   Risk Level: ${cache.risk.level}`,10,y);
  y+=10;

  pdf.text("Forecast Overview",10,y); 
  y+=5;
  pdf.addImage(lineChart.toDataURL(),"PNG",10,y,180,55);
  y+=65;

  pdf.text("KPI Summary",10,y); 
  y+=5;
  pdf.addImage(kpiChart.toDataURL(),"PNG",10,y,85,45);
  pdf.addImage(productChart.toDataURL(),"PNG",105,y,85,45);
  y+=55;

  pdf.text("Scenario Forecast",10,y); 
  y+=6;
  pdf.text(`Base: ${cache.scenarios.base.join(", ")}`,10,y); y+=6;
  pdf.text(`Optimistic: ${cache.scenarios.optimistic.join(", ")}`,10,y); y+=6;
  pdf.text(`Conservative: ${cache.scenarios.conservative.join(", ")}`,10,y); y+=10;

  pdf.text("AI Strategy Summary",10,y); 
  y+=6;
  pdf.text(aiText.value,10,y,{maxWidth:180});

  pdf.save("paragon_report.pdf");
}

/* ---------------- MATH ---------------- */

function mean(a){return a.reduce((x,y)=>x+y,0)/a.length;}
function std(a){let m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)**2)));}

</script>
</body>
</html>
