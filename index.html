<!DOCTYPE html>
<!--
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘            PARAGON ANALYTICS â€” Executive Forecasting          â•‘
  â•‘                   GitHub Pages Ready v3.1                     â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘  CORRECTIONS FROM v3.0:                                       â•‘
  â•‘  1. Holdout MAPE â€” true out-of-sample validation (25% split)  â•‘
  â•‘     replaces misleading in-sample EMA vs actual comparison    â•‘
  â•‘  2. Confidence Score â€” now derived from holdout MAPE +        â•‘
  â•‘     directional accuracy + sample size; no longer uses        â•‘
  â•‘     the invented RÂ²Ã—70 + sampleFactorÃ—25 formula             â•‘
  â•‘  3. Naive comparison â€” uses same holdout period for fair      â•‘
  â•‘     apples-to-apples EMA vs naive benchmarking               â•‘
  â•‘  4. Small-dataset fallback â€” graceful degradation when        â•‘
  â•‘     series is too short for a meaningful holdout split        â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Paragon Analytics â€” Executive Forecasting</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=DM+Mono:wght@300;400;500&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg:      #08090d;
      --surface: #0f1118;
      --border:  #1e2230;
      --accent:  #c9a84c;
      --accent2: #4c8ec9;
      --green:   #22c55e;
      --amber:   #f59e0b;
      --red:     #ef4444;
      --text:    #e8e9ef;
      --muted:   #6b7280;
      --card-bg: #11131c;
    }
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }
    body::before {
      content: '';
      position: fixed; inset: 0; z-index: 0; pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");
      opacity: 0.6;
    }

    header {
      position: relative; z-index: 10;
      display: flex; align-items: center; justify-content: space-between;
      padding: 1.2rem 2.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(8,9,13,0.92);
      backdrop-filter: blur(12px);
    }
    .logo { display: flex; align-items: baseline; gap: 0.5rem; }
    .logo-name {
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem; font-weight: 700;
      color: var(--text); letter-spacing: -0.02em;
    }
    .logo-badge {
      font-family: 'DM Mono', monospace;
      font-size: 0.65rem; font-weight: 500;
      color: var(--accent); border: 1px solid var(--accent);
      padding: 1px 6px; border-radius: 3px;
      letter-spacing: 0.08em; text-transform: uppercase;
    }
    .header-right {
      display: flex; align-items: center; gap: 1rem;
      font-family: 'DM Mono', monospace;
      font-size: 0.72rem; color: var(--muted); letter-spacing: 0.05em;
    }
    #clock { color: var(--accent); }
    .btn-sample {
      display: inline-flex; align-items: center; gap: 0.4rem;
      padding: 0.35rem 0.9rem;
      border: 1px solid var(--accent2); border-radius: 5px;
      background: rgba(76,142,201,0.08);
      color: var(--accent2);
      font-family: 'DM Mono', monospace;
      font-size: 0.7rem; cursor: pointer;
      transition: all 0.18s; letter-spacing: 0.05em;
    }
    .btn-sample:hover { background: rgba(76,142,201,0.18); }

    main {
      position: relative; z-index: 1;
      max-width: 1200px; margin: 0 auto;
      padding: 2rem 2rem 4rem;
      display: flex; flex-direction: column; gap: 1.5rem;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px; padding: 1.5rem;
      transition: border-color 0.2s;
    }
    .card:hover { border-color: #2a2f45; }
    .card-title {
      font-family: 'DM Mono', monospace;
      font-size: 0.68rem; font-weight: 500;
      color: var(--muted); letter-spacing: 0.12em;
      text-transform: uppercase; margin-bottom: 1rem;
      display: flex; align-items: center; gap: 0.5rem;
    }
    .card-title::before {
      content: ''; display: inline-block;
      width: 6px; height: 6px;
      background: var(--accent); border-radius: 50%;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 0.75rem; align-items: center;
    }
    .controls-row2 {
      display: flex; gap: 0.75rem; align-items: center;
      margin-top: 0.75rem; flex-wrap: wrap;
    }
    .upload-zone {
      border: 1.5px dashed var(--border);
      border-radius: 8px; padding: 1.2rem 1.5rem;
      display: flex; align-items: center; gap: 1rem;
      cursor: pointer; transition: all 0.2s;
      background: rgba(201,168,76,0.03);
    }
    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--accent); background: rgba(201,168,76,0.07);
    }
    .upload-icon { font-size: 1.5rem; }
    .upload-text { font-size: 0.85rem; color: var(--muted); }
    .upload-text strong { color: var(--text); display: block; font-size: 0.9rem; }
    #csvFile { display: none; }

    .select-wrap { position: relative; }
    select {
      appearance: none;
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 6px; padding: 0.6rem 2.5rem 0.6rem 1rem;
      color: var(--text); font-family: 'DM Sans', sans-serif;
      font-size: 0.88rem; cursor: pointer;
      transition: border-color 0.2s; min-width: 160px;
    }
    select:focus { outline: none; border-color: var(--accent); }
    .select-wrap::after {
      content: 'â–¾'; position: absolute; right: 0.75rem;
      top: 50%; transform: translateY(-50%);
      color: var(--muted); pointer-events: none; font-size: 0.8rem;
    }

    .label-sm {
      font-family: 'DM Mono', monospace; font-size: 0.68rem;
      color: var(--muted); letter-spacing: 0.08em; text-transform: uppercase;
      display: block; margin-bottom: 0.25rem;
    }

    input[type="range"] {
      -webkit-appearance: none;
      height: 4px; border-radius: 2px;
      background: var(--border); cursor: pointer; vertical-align: middle;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 14px; border-radius: 50%;
      background: var(--accent); cursor: pointer;
    }

    .btn {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.6rem 1.4rem; border: none; border-radius: 6px;
      font-family: 'DM Sans', sans-serif; font-size: 0.88rem;
      font-weight: 500; cursor: pointer; transition: all 0.18s; white-space: nowrap;
    }
    .btn-primary { background: var(--accent); color: #08090d; }
    .btn-primary:hover { background: #dab85a; transform: translateY(-1px); }
    .btn-secondary {
      background: transparent; color: var(--muted); border: 1px solid var(--border);
    }
    .btn-secondary:hover { border-color: var(--accent2); color: var(--accent2); }
    .btn-ghost {
      background: transparent; color: var(--muted); border: 1px solid var(--border);
      font-size: 0.82rem; padding: 0.5rem 1rem;
    }
    .btn-ghost:hover { border-color: var(--green); color: var(--green); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }

    .preview-table-wrap {
      overflow-x: auto; max-height: 180px; overflow-y: auto;
      border: 1px solid var(--border); border-radius: 6px; margin-top: 0.75rem;
    }
    .preview-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .preview-table th {
      background: var(--surface); position: sticky; top: 0;
      font-family: 'DM Mono', monospace; font-size: 0.65rem;
      color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em;
      padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border);
      text-align: left; white-space: nowrap;
    }
    .preview-table td {
      padding: 0.4rem 0.75rem; border-bottom: 1px solid rgba(30,34,48,0.5);
      color: var(--text); white-space: nowrap; font-family: 'DM Mono', monospace;
    }
    .preview-table tr:last-child td { border-bottom: none; }
    .preview-table tr:hover td { background: rgba(201,168,76,0.04); }
    .col-numeric { color: var(--accent) !important; }
    .col-date   { color: var(--accent2) !important; }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
    }
    .kpi-card {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 8px; padding: 1.1rem 1.3rem;
      position: relative; overflow: hidden;
    }
    .kpi-card::after {
      content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 2px;
    }
    .kpi-card.green::after { background: var(--green); }
    .kpi-card.amber::after { background: var(--amber); }
    .kpi-card.red::after   { background: var(--red); }
    .kpi-card.blue::after  { background: var(--accent2); }
    .kpi-label {
      font-family: 'DM Mono', monospace; font-size: 0.62rem; color: var(--muted);
      text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.4rem;
    }
    .kpi-value {
      font-size: 1.6rem; font-weight: 300;
      font-family: 'Playfair Display', serif; line-height: 1;
    }
    .kpi-sub { font-family: 'DM Mono', monospace; font-size: 0.7rem; margin-top: 0.3rem; }
    .kpi-sub.green { color: var(--green); }
    .kpi-sub.amber { color: var(--amber); }
    .kpi-sub.red   { color: var(--red); }

    .chart-wrap { position: relative; height: 360px; }
    #trendChart { width: 100% !important; height: 100% !important; }

    .scenario-header {
      display: grid; grid-template-columns: 1.2fr repeat(3, 1fr);
      gap: 0.5rem; margin-bottom: 0.4rem; padding: 0 0.25rem;
    }
    .scenario-header-cell {
      font-family: 'DM Mono', monospace; font-size: 0.62rem;
      color: var(--muted); text-align: center;
      text-transform: uppercase; letter-spacing: 0.08em;
    }
    .scenario-rows { display: flex; flex-direction: column; gap: 0.5rem; }
    .scenario-row { display: grid; grid-template-columns: 1.2fr repeat(3, 1fr); gap: 0.5rem; }
    .scenario-label-cell {
      display: flex; align-items: center;
      font-family: 'DM Mono', monospace; font-size: 0.75rem; color: var(--muted);
      border: 1px solid var(--border); border-radius: 6px; padding: 0.6rem 0.8rem;
      background: var(--surface);
    }
    .scenario-value-cell {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 6px; padding: 0.6rem; text-align: center;
    }
    .scenario-value-cell .val {
      font-family: 'Playfair Display', serif; font-size: 1.05rem; line-height: 1;
    }
    .scenario-value-cell .delta {
      font-family: 'DM Mono', monospace; font-size: 0.6rem;
      color: var(--muted); margin-top: 0.25rem;
    }
    .scenario-row.opt .val { color: var(--green); }
    .scenario-row.base .val { color: var(--accent); }
    .scenario-row.pess .val { color: var(--red); }

    #logOutput {
      font-family: 'DM Mono', monospace; font-size: 0.75rem;
      color: var(--muted); line-height: 1.7; white-space: pre-wrap;
    }
    #logOutput .log-ok   { color: var(--green); }
    #logOutput .log-warn { color: var(--amber); }
    #logOutput .log-info { color: var(--accent2); }

    .hidden { display: none !important; }
    .section-divider {
      display: flex; align-items: center; gap: 1rem;
      color: var(--muted); font-family: 'DM Mono', monospace;
      font-size: 0.68rem; letter-spacing: 0.1em;
    }
    .section-divider::before, .section-divider::after {
      content: ''; flex: 1; height: 1px; background: var(--border);
    }

    #toast {
      position: fixed; bottom: 2rem; right: 2rem; z-index: 999;
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 8px; padding: 0.8rem 1.4rem; font-size: 0.85rem;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      transform: translateY(20px); opacity: 0;
      transition: all 0.3s; pointer-events: none;
    }
    #toast.show { transform: translateY(0); opacity: 1; }
    #toast.err  { border-color: var(--red); color: var(--red); }

    @keyframes fadeSlide {
      from { opacity: 0; transform: translateY(12px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .animate-in { animation: fadeSlide 0.4s ease both; }
    .delay-1 { animation-delay: 0.08s; }
    .delay-2 { animation-delay: 0.16s; }
    .delay-3 { animation-delay: 0.24s; }

    @media (max-width: 768px) {
      header { padding: 1rem 1.2rem; flex-wrap: wrap; gap: 0.5rem; }
      main { padding: 1rem 1rem 3rem; }
      .controls-grid { grid-template-columns: 1fr; }
      .scenario-header, .scenario-row { grid-template-columns: 1fr 1fr 1fr; }
      .scenario-label-cell { display: none; }
      .scenario-header-cell:first-child { display: none; }
    }

    #pdfChartCanvas {
      position: fixed;
      top: -9999px; left: -9999px;
      visibility: hidden;
      pointer-events: none;
    }
  </style>
</head>
<body>

<header>
  <div class="logo">
    <span class="logo-name">Paragon</span>
    <span class="logo-badge">Analytics</span>
  </div>
  <div class="header-right">
    <button class="btn-sample" onclick="loadSampleData()" title="Load built-in demo dataset">
      âš¡ Load Sample Data
    </button>
    Executive Forecasting &nbsp;|&nbsp; <span id="clock"></span>
  </div>
</header>

<main>

  <div class="card animate-in">
    <div class="card-title">Data Input &amp; Configuration</div>
    <div class="controls-grid">
      <div class="upload-zone" id="uploadZone" onclick="document.getElementById('csvFile').click()">
        <div class="upload-icon">ğŸ“‚</div>
        <div class="upload-text">
          <strong id="fileName">Upload CSV / TSV File</strong>
          Drag &amp; drop or click to browse
        </div>
        <input type="file" id="csvFile" accept=".csv,.tsv,.txt" />
      </div>
      <div class="select-wrap">
        <select id="metricSelect">
          <option value="">â€” Select Metric â€”</option>
        </select>
      </div>
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
        <button class="btn btn-primary" id="analyzeBtn" disabled>â–¶ Analyze</button>
        <button class="btn btn-secondary" id="pdfBtn" disabled>â¬‡ Export PDF</button>
        <button class="btn btn-ghost" id="csvExportBtn" disabled>â¬‡ CSV</button>
      </div>
    </div>
    <div class="controls-row2">
      <div>
        <span class="label-sm">EMA Smoothing (Î±)</span>
        <div style="display:flex; align-items:center; gap:0.5rem;">
          <input type="range" id="alphaRange" min="0.05" max="0.6" step="0.05" value="0.3" style="width:100px">
          <span id="alphaVal" style="font-family:'DM Mono',monospace; font-size:0.75rem; color:var(--accent);">0.30</span>
        </div>
      </div>
      <div>
        <span class="label-sm">Forecast Periods</span>
        <div style="display:flex; align-items:center; gap:0.5rem;">
          <input type="range" id="horizonRange" min="1" max="8" step="1" value="3" style="width:100px">
          <span id="horizonVal" style="font-family:'DM Mono',monospace; font-size:0.75rem; color:var(--accent);">3</span>
        </div>
      </div>
      <div id="dateColWrap" class="hidden">
        <span class="label-sm">Date / Label Column</span>
        <div class="select-wrap">
          <select id="dateSelect" style="min-width:130px;">
            <option value="">â€” None â€”</option>
          </select>
        </div>
      </div>
    </div>
    <div id="previewWrap" class="hidden">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:1rem; margin-bottom:0.3rem;">
        <span style="font-family:'DM Mono',monospace; font-size:0.65rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.1em;">Data Preview â€” first 6 rows</span>
        <span id="previewStats" style="font-family:'DM Mono',monospace; font-size:0.65rem; color:var(--muted);"></span>
      </div>
      <div class="preview-table-wrap">
        <table class="preview-table" id="previewTable"></table>
      </div>
    </div>
  </div>

  <div id="kpiSection" class="hidden animate-in delay-1">
    <div class="card-title" style="margin-bottom:0.75rem;">Business Summary</div>
    <div class="kpi-grid" id="kpiGrid"></div>
  </div>

  <div id="chartSection" class="card hidden animate-in delay-2">
    <div class="card-title">Trend &amp; Forecast</div>
    <div class="chart-wrap">
      <canvas id="trendChart"></canvas>
    </div>
  </div>

  <div id="scenarioSection" class="hidden animate-in delay-3">
    <div class="section-divider" id="scenarioDivider">Scenario Analysis</div>
    <div style="margin-top:0.75rem;">
      <div class="scenario-header" id="scenarioHeader">
        <div class="scenario-header-cell"></div>
      </div>
      <div class="scenario-rows" id="scenarioRows"></div>
    </div>
  </div>

  <div id="logSection" class="card hidden">
    <div class="card-title">Analysis Log</div>
    <pre id="logOutput"></pre>
  </div>

</main>

<div id="toast"></div>
<canvas id="pdfChartCanvas"></canvas>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLOCK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tick() {
  document.getElementById('clock').textContent =
    new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
}
tick(); setInterval(tick, 1000);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let rows = [], headers = [], numericCols = [], dateCols = [];
let metric = null, dateCol = null;
let chartObj = null, lastAnalysis = null;
let alpha = 0.3, horizon = 3;

const $ = id => document.getElementById(id);
const csvFile      = $('csvFile');
const analyzeBtn   = $('analyzeBtn');
const pdfBtn       = $('pdfBtn');
const csvExportBtn = $('csvExportBtn');
const metricSelect = $('metricSelect');
const dateSelect   = $('dateSelect');
const uploadZone   = $('uploadZone');
const fileName     = $('fileName');
const alphaRange   = $('alphaRange');
const horizonRange = $('horizonRange');
const alphaVal     = $('alphaVal');
const horizonVal   = $('horizonVal');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEBOUNCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function debounce(fn, ms) {
  let timer;
  return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), ms); };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alphaRange.addEventListener('input', debounce(() => {
  alpha = +alphaRange.value;
  alphaVal.textContent = alpha.toFixed(2);
  if (metric) analyze();
}, 100));

horizonRange.addEventListener('input', debounce(() => {
  horizon = +horizonRange.value;
  horizonVal.textContent = horizon;
  if (metric) analyze();
}, 100));

metricSelect.addEventListener('change', () => {
  metric = metricSelect.value;
  saveSettings();
  if (metric) analyze();
});

dateSelect.addEventListener('change', () => {
  dateCol = dateSelect.value || null;
  if (metric) analyze();
});

analyzeBtn.addEventListener('click', () => analyze());
pdfBtn.addEventListener('click', () => exportPDF());
csvExportBtn.addEventListener('click', () => exportForecastCSV());

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS PERSISTENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function saveSettings() {
  try {
    localStorage.setItem('paragon_settings', JSON.stringify({
      alpha, horizon, lastMetric: metric, timestamp: Date.now()
    }));
  } catch(e) {}
}

function loadSettings() {
  try {
    const saved = localStorage.getItem('paragon_settings');
    if (saved) {
      const s = JSON.parse(saved);
      if (Date.now() - s.timestamp < 30 * 24 * 60 * 60 * 1000) {
        alpha = s.alpha || 0.3; horizon = s.horizon || 3;
        alphaRange.value = alpha; horizonRange.value = horizon;
        alphaVal.textContent = alpha.toFixed(2); horizonVal.textContent = horizon;
        return s.lastMetric;
      }
    }
  } catch(e) {}
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAG & DROP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
uploadZone.addEventListener('drop', e => {
  e.preventDefault(); uploadZone.classList.remove('dragover');
  const f = e.dataTransfer.files[0]; if (f) readFile(f);
});
csvFile.addEventListener('change', () => { if (csvFile.files[0]) readFile(csvFile.files[0]); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAMPLE DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadSampleData() {
  const csv = `date,revenue,units_sold,avg_order_value,customer_count
2023-01,142500,1420,100.35,1050
2023-02,138900,1380,100.65,1030
2023-03,151200,1490,101.48,1120
2023-04,163400,1600,102.13,1200
2023-05,171000,1660,103.01,1250
2023-06,168700,1630,103.50,1230
2023-07,175300,1690,103.73,1270
2023-08,180100,1730,104.10,1310
2023-09,188400,1800,104.67,1360
2023-10,195700,1860,105.22,1400
2023-11,214300,2020,106.09,1540
2023-12,231800,2180,106.33,1680
2024-01,198400,1870,106.10,1430
2024-02,195200,1840,106.09,1420
2024-03,210500,1970,106.85,1510
2024-04,221800,2060,107.67,1590
2024-05,229300,2120,108.16,1640
2024-06,234700,2160,108.66,1670
2024-07,241100,2210,109.09,1710
2024-08,249800,2280,109.56,1760
2024-09,258400,2350,109.96,1810
2024-10,267900,2430,110.25,1870
2024-11,291200,2640,110.30,2050
2024-12,318500,2880,110.59,2240`;
  fileName.textContent = 'sample_business_data.csv';
  parse(csv);
  toast('âœ“ Sample dataset loaded â€” 24 months of business data');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE READ + PARSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function readFile(file) {
  fileName.textContent = file.name;
  const r = new FileReader();
  r.onload = e => parse(e.target.result);
  r.readAsText(file);
}

function parseCSVLine(line, delim) {
  const fields = []; let cur = '', inQ = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') { if (inQ && line[i+1] === '"') { cur += '"'; i++; } else inQ = !inQ; }
    else if (c === delim && !inQ) { fields.push(cur.trim()); cur = ''; }
    else cur += c;
  }
  fields.push(cur.trim()); return fields;
}

function isDateLike(val) {
  if (typeof val !== 'string') return false;
  return /^\d{4}[-/]\d{1,2}([-/]\d{1,2})?$/.test(val) ||
         /^Q[1-4]\s*\d{4}$/i.test(val) || /^\d{1,2}[-/]\d{4}$/.test(val) ||
         /^\d{4}$/.test(val);
}

function parse(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const delim = [',', ';', '\t', '|'].find(x => parseCSVLine(lines[0], x).length > 1) || ',';
  headers = parseCSVLine(lines[0], delim).map(h =>
    h.replace(/^["']|["']$/g,'').toLowerCase().replace(/\W+/g,'_'));
  rows = lines.slice(1).map(l => {
    const p = parseCSVLine(l, delim); const o = {};
    headers.forEach((h, i) => {
      const raw = (p[i] || '').replace(/^["']|["']$/g,'').trim();
      o[h] = (!isNaN(+raw) && raw !== '') ? +raw : raw;
    }); return o;
  }).filter(r => headers.some(h => typeof r[h] === 'number'));

  numericCols = headers.filter(h => rows.some(r => typeof r[h] === 'number'));
  dateCols = headers.filter(h =>
    !numericCols.includes(h) || rows.slice(0,5).some(r => isDateLike(String(r[h]))));

  metricSelect.innerHTML = '<option value="">â€” Select Metric â€”</option>' +
    numericCols.map(c => `<option value="${c}">${c.replace(/_/g,' ')}</option>`).join('');

  const dcWrap = $('dateColWrap');
  if (dateCols.length) {
    dcWrap.classList.remove('hidden');
    dateSelect.innerHTML = '<option value="">â€” None â€”</option>' +
      dateCols.map(c => `<option value="${c}">${c.replace(/_/g,' ')}</option>`).join('');
    const auto = dateCols.find(c => /date|period|month|year|week|quarter/i.test(c));
    if (auto) { dateSelect.value = auto; dateCol = auto; }
  } else { dcWrap.classList.add('hidden'); dateCol = null; }

  buildPreview();
  const lastMetric = loadSettings();
  metric = lastMetric && numericCols.includes(lastMetric) ? lastMetric : (numericCols[0] || null);
  if (metric) { metricSelect.value = metric; analyze(); }
  analyzeBtn.disabled = false;
  $('previewStats').textContent = `${rows.length} rows Â· ${numericCols.length} numeric Â· ${dateCols.length} date`;
  $('previewWrap').classList.remove('hidden');
}

function buildPreview() {
  const t = $('previewTable'); const show = rows.slice(0, 6);
  t.innerHTML = `<thead><tr>${headers.map(h => {
    const cls = numericCols.includes(h) ? 'col-numeric' : dateCols.includes(h) ? 'col-date' : '';
    return `<th class="${cls}">${h.replace(/_/g,' ')}</th>`;
  }).join('')}</tr></thead>` +
  `<tbody>${show.map(r => `<tr>${headers.map(h => {
    const cls = numericCols.includes(h) ? 'col-numeric' : dateCols.includes(h) ? 'col-date' : '';
    return `<td class="${cls}">${r[h] !== undefined ? r[h] : ''}</td>`;
  }).join('')}</tr>`).join('')}</tbody>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATH HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mean(a) { return a.reduce((x,y) => x+y, 0) / a.length; }

function std(a) {
  const m = mean(a);
  return Math.sqrt(a.reduce((acc, v) => acc + (v-m)**2, 0) / a.length);
}

function ema(a, alpha) {
  const o = [a[0]];
  for (let i = 1; i < a.length; i++)
    o.push(alpha * a[i] + (1 - alpha) * o[i-1]);
  return o;
}

function forecast(last, slope, n) {
  return Array.from({length: n}, (_, i) => +(last + slope * (i + 1)).toFixed(6));
}

/**
 * MAPE â€” Mean Absolute Percentage Error.
 * Only defined where actual !== 0.
 */
function mape(actual, predicted) {
  let sum = 0, count = 0;
  for (let i = 0; i < Math.min(actual.length, predicted.length); i++) {
    if (actual[i] !== 0) {
      sum += Math.abs((actual[i] - predicted[i]) / actual[i]);
      count++;
    }
  }
  return count > 0 ? (sum / count * 100) : 0;
}

function directionalAccuracy(actual, predicted) {
  if (actual.length < 2 || predicted.length < 2) return 0;
  let correct = 0, total = 0;
  for (let i = 1; i < Math.min(actual.length, predicted.length); i++) {
    if (Math.sign(actual[i] - actual[i-1]) === Math.sign(predicted[i] - predicted[i-1])) correct++;
    total++;
  }
  return total > 0 ? (correct / total * 100) : 0;
}

function maxDrawdown(series) {
  let peak = -Infinity, maxDD = 0;
  for (const v of series) {
    if (v > peak) peak = v;
    const dd = (peak - v) / peak;
    if (dd > maxDD) maxDD = dd;
  }
  return maxDD * 100;
}

function detectSeasonality(series, maxPeriod = 12) {
  if (series.length < maxPeriod * 2) return null;
  const correlation = (x, y) => {
    const n = Math.min(x.length, y.length);
    const mx = mean(x.slice(0,n)), my = mean(y.slice(0,n));
    let num = 0, denx = 0, deny = 0;
    for (let i = 0; i < n; i++) {
      const dx = x[i]-mx, dy = y[i]-my;
      num += dx*dy; denx += dx*dx; deny += dy*dy;
    }
    return num / Math.sqrt(denx * deny);
  };
  let bestLag = null, bestCorr = 0;
  for (let lag = 2; lag <= maxPeriod; lag++) {
    const c = correlation(series.slice(0,-lag), series.slice(lag));
    if (c > bestCorr && c > 0.3) { bestCorr = c; bestLag = lag; }
  }
  return bestLag ? { period: bestLag, strength: bestCorr } : null;
}

function detectOutliers(series) {
  const sorted = [...series].sort((a,b) => a-b);
  const q1 = sorted[Math.floor(sorted.length * 0.25)];
  const q3 = sorted[Math.floor(sorted.length * 0.75)];
  const iqr = q3 - q1;
  const lower = q1 - 1.5 * iqr, upper = q3 + 1.5 * iqr;
  return series.map((v,i) => ({index:i, value:v, isOutlier: v<lower||v>upper}))
               .filter(x => x.isOutlier);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIX 1 â€” HOLDOUT VALIDATION
// Holds out the last 25% of the series (minimum 3 points) as a
// true out-of-sample test set. Trains EMA on the remaining data,
// generates step-ahead forecasts into the holdout window, and
// calculates MAPE on those unseen points. The same holdout is used
// to benchmark against a naive (last-value) forecast, making the
// EMA-vs-naive comparison a fair apples-to-apples test.
//
// Returns null when the series is too short for a meaningful split
// (< 8 points), triggering a transparent fallback in the UI.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function holdoutValidation(series, alpha) {
  const MIN_TRAIN = 5;
  const MIN_HOLDOUT = 3;
  if (series.length < MIN_TRAIN + MIN_HOLDOUT) return null; // too small

  const holdoutSize = Math.max(MIN_HOLDOUT, Math.round(series.length * 0.25));
  const train   = series.slice(0, -holdoutSize);
  const holdout = series.slice(-holdoutSize);

  if (train.length < MIN_TRAIN) return null;

  // EMA on training data only
  const trainSmooth = ema(train, alpha);
  const lastEma     = trainSmooth[trainSmooth.length - 1];

  // Slope from the tail of the training EMA (same logic as main analyze)
  const tailLen    = Math.max(3, Math.round(trainSmooth.length * 0.25));
  const tail       = trainSmooth.slice(-tailLen);
  const trainSlope = (tail[tail.length - 1] - tail[0]) / (tail.length - 1);

  // Generate one forecast per holdout step (iterated, not direct)
  const emaForecast = forecast(lastEma, trainSlope, holdoutSize);

  // Naive baseline: repeat last observed training value for each holdout step
  const naiveForecast = Array(holdoutSize).fill(train[train.length - 1]);

  return {
    holdoutSize,
    holdoutActual:   holdout,
    emaForecast,
    naiveForecast,
    holdoutMape:     mape(holdout, emaForecast),
    naiveMape:       mape(holdout, naiveForecast),
    holdoutDirAcc:   directionalAccuracy(holdout, emaForecast),
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIX 2 â€” CONFIDENCE SCORE
// Replaces the previous RÂ²Ã—70 + sampleFactorÃ—25 formula, which
// inflated confidence for any autocorrelated series regardless of
// actual predictive accuracy.
//
// The new score has three grounded components:
//   â€¢ MAPE factor  (55 pts max) â€” inverts holdout MAPE on a curve
//     capped at 50%: a 0% MAPE gives full marks; 50%+ gives zero.
//   â€¢ Directional accuracy (30 pts max) â€” proportion of correct
//     up/down calls on holdout; 100% gives full marks.
//   â€¢ Sample size factor  (15 pts max) â€” log-scaled, saturates
//     around 30 data points to avoid over-rewarding large datasets.
//
// When no holdout is available (< 8 points), the score is capped
// at 60 and flagged as estimated so users know it is less reliable.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function computeConfidence(holdoutResult, dirAcc, sampleSize) {
  const sampleFactor = Math.min(1, Math.log(sampleSize + 1) / Math.log(30));

  if (!holdoutResult) {
    // Insufficient data for holdout â€” partial score, capped lower
    const raw = dirAcc * 0.4 + sampleFactor * 20;
    return { score: Math.round(Math.max(10, Math.min(60, raw))), estimated: true };
  }

  // Primary driver: out-of-sample MAPE (0% â†’ 1.0, 50%+ â†’ 0.0)
  const mapeFactor = Math.max(0, 1 - holdoutResult.holdoutMape / 50);

  // Directional accuracy on holdout (0â€“1)
  const dirFactor = holdoutResult.holdoutDirAcc / 100;

  const raw = mapeFactor * 55 + dirFactor * 30 + sampleFactor * 15;
  return { score: Math.round(Math.max(10, Math.min(95, raw))), estimated: false };
}

function fmtNum(v) {
  if (!isFinite(v) || isNaN(v)) return 'â€”';
  if (Math.abs(v) >= 1e6)  return (v/1e6).toFixed(2) + 'M';
  if (Math.abs(v) >= 1e3)  return (v/1e3).toFixed(1) + 'K';
  if (Math.abs(v) < 0.01 && v !== 0) return v.toExponential(2);
  return v.toFixed(2);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANALYZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function analyze() {
  if (!metric) return;
  const s = rows.map(r => r[metric]).filter(v => typeof v === 'number');
  if (s.length < 4) { toast('Need at least 4 numeric data points', true); return; }

  const labels = dateCol
    ? rows.map(r => String(r[dateCol]))
    : s.map((_, i) => `P${i + 1}`);

  const avg   = mean(s);
  const sigma = std(s);
  const vol   = sigma / Math.abs(avg);
  const smooth = ema(s, alpha);

  const tailLen = Math.max(3, Math.round(smooth.length * 0.25));
  const tail    = smooth.slice(-tailLen);
  const slope   = (tail[tail.length - 1] - tail[0]) / (tail.length - 1);

  // RÂ² (goodness of fit for EMA smoother â€” kept for log transparency)
  const ssTot = s.reduce((acc, v) => acc + (v - avg) ** 2, 0);
  const ssRes = s.reduce((acc, v, i) => acc + (v - smooth[i]) ** 2, 0);
  const r2    = ssTot > 0 ? Math.max(0, 1 - ssRes / ssTot) : 0;

  // Forecasts
  const lastActual = s[s.length - 1];
  const lastEma    = smooth[smooth.length - 1];
  const base = forecast(lastEma, slope, horizon);
  const opt  = base.map(v => v + sigma);
  const pess = base.map(v => v - sigma);

  const trendDir = slope >  0.001 * avg ? 'â†‘ Upward'
                 : slope < -0.001 * avg ? 'â†“ Downward' : 'â†’ Flat';
  const trendColor = slope > 0.001 * avg ? 'var(--green)'
                   : slope < -0.001 * avg ? 'var(--red)' : 'var(--amber)';
  const pctChange = lastActual !== 0
    ? ((base[0] - lastActual) / Math.abs(lastActual) * 100).toFixed(1) : 'â€“';
  const pctSign = parseFloat(pctChange) >= 0 ? '+' : '';

  // Seasonality / outliers (unchanged, data quality metrics)
  const seasonality = detectSeasonality(s);
  const outliers    = detectOutliers(s);

  // In-sample directional accuracy (for display in KPI alongside holdout)
  const inSampleDirAcc = directionalAccuracy(s, smooth);

  // â”€â”€ FIX: TRUE OUT-OF-SAMPLE HOLDOUT VALIDATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const holdout = holdoutValidation(s, alpha);

  // â”€â”€ FIX: GROUNDED CONFIDENCE SCORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { score: conf, estimated: confEstimated } = computeConfidence(holdout, inSampleDirAcc, s.length);
  const badge = conf > 72 ? 'green' : conf > 50 ? 'amber' : 'red';

  // Surface the holdout MAPE as the headline accuracy metric.
  // Fall back to in-sample (with disclaimer) only when data is too short.
  const displayMape     = holdout ? holdout.holdoutMape : mape(s.slice(1), smooth.slice(1));
  const mapeIsHoldout   = holdout !== null;
  const emaBeatsNaive   = holdout ? holdout.holdoutMape < holdout.naiveMape
                                  : false; // can't claim win without holdout
  const naiveMapeVal    = holdout ? holdout.naiveMape : null;

  const maxDD = maxDrawdown(s);

  lastAnalysis = {
    metric, s, smooth, labels, base, opt, pess, avg, sigma, vol,
    slope, conf, badge, r2, trendDir, pctChange, pctSign,
    modelQuality: {
      mape: displayMape,
      mapeIsHoldout,
      holdoutSize: holdout ? holdout.holdoutSize : 0,
      directionalAccuracy: inSampleDirAcc,
      holdoutDirAcc: holdout ? holdout.holdoutDirAcc : null,
      maxDrawdown: maxDD,
      seasonality,
      outliers,
      emaBeatsNaive,
      naiveMape: naiveMapeVal,
      confEstimated,
    }
  };

  const mq = lastAnalysis.modelQuality;

  // â”€â”€ KPI GRID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const seasonText  = mq.seasonality
    ? `${mq.seasonality.period}-period cycle (${(mq.seasonality.strength*100).toFixed(0)}%)`
    : 'None detected';
  const outlierText = mq.outliers.length > 0
    ? `${mq.outliers.length} outlier${mq.outliers.length > 1 ? 's' : ''} detected`
    : 'No outliers';

  // Accuracy card label changes depending on whether holdout was possible
  const mapeLabel = mq.mapeIsHoldout
    ? `Holdout MAPE (n=${mq.holdoutSize})`
    : 'In-Sample MAPE âš ';
  const mapeQuality = mq.mape < 10 ? 'Excellent' : mq.mape < 20 ? 'Good' : 'Poor';
  const mapeClass   = mq.mape < 10 ? 'green' : mq.mape < 20 ? 'amber' : 'red';

  const confLabel = mq.confEstimated ? 'Confidence (est.)' : 'Confidence Score';

  $('kpiGrid').innerHTML = `
    <div class="kpi-card blue">
      <div class="kpi-label">Metric</div>
      <div class="kpi-value" style="font-size:1.05rem; padding-top:0.3rem;">${metric.replace(/_/g,' ')}</div>
      <div class="kpi-sub" style="color:var(--muted)">${s.length} data points</div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">Average</div>
      <div class="kpi-value">${fmtNum(avg)}</div>
      <div class="kpi-sub" style="color:var(--muted)">Ïƒ = ${fmtNum(sigma)}</div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">Trend Direction</div>
      <div class="kpi-value" style="font-size:1.15rem; padding-top:0.2rem; color:${trendColor}">${trendDir}</div>
      <div class="kpi-sub" style="color:var(--muted)">Next period: ${pctSign}${pctChange}%</div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">${mapeLabel}</div>
      <div class="kpi-value">${mq.mape.toFixed(1)}%</div>
      <div class="kpi-sub ${mapeClass}">
        â— ${mapeQuality}${mq.mapeIsHoldout ? ' Â· out-of-sample' : ' Â· no holdout'}
      </div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">Directional Accuracy</div>
      <div class="kpi-value">${mq.directionalAccuracy.toFixed(0)}%</div>
      <div class="kpi-sub" style="color:var(--muted)">
        ${mq.holdoutDirAcc !== null ? `Holdout: ${mq.holdoutDirAcc.toFixed(0)}%` : 'In-sample (full series)'}
      </div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">Max Drawdown</div>
      <div class="kpi-value">${mq.maxDrawdown.toFixed(1)}%</div>
      <div class="kpi-sub ${mq.maxDrawdown < 10 ? 'green' : mq.maxDrawdown < 25 ? 'amber' : 'red'}">
        Peak-to-trough risk
      </div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">Seasonality</div>
      <div class="kpi-value" style="font-size:1.05rem; padding-top:0.3rem; color:${mq.seasonality ? 'var(--accent)' : 'var(--muted)'}">
        ${mq.seasonality ? mq.seasonality.period + '-period' : 'None'}
      </div>
      <div class="kpi-sub" style="color:var(--muted)">${seasonText}</div>
    </div>
    <div class="kpi-card ${mq.outliers.length > 0 ? 'amber' : ''}">
      <div class="kpi-label">Data Quality</div>
      <div class="kpi-value" style="font-size:1.05rem; padding-top:0.3rem;">
        ${mq.outliers.length > 0 ? mq.outliers.length + ' issues' : 'Clean'}
      </div>
      <div class="kpi-sub ${mq.outliers.length > 0 ? 'amber' : 'green'}">${outlierText}</div>
    </div>
    <div class="kpi-card ${mq.emaBeatsNaive ? 'green' : 'amber'}">
      <div class="kpi-label">Model vs Naive</div>
      <div class="kpi-value" style="font-size:1.05rem; padding-top:0.3rem;">
        ${mq.emaBeatsNaive ? 'EMA âœ“' : mq.naiveMape !== null ? 'Caution' : 'N/A'}
      </div>
      <div class="kpi-sub ${mq.emaBeatsNaive ? 'green' : 'amber'}">
        ${mq.emaBeatsNaive
          ? `Beats naive by ${(mq.naiveMape - mq.mape).toFixed(1)}% MAPE`
          : mq.naiveMape !== null
            ? `Naive MAPE: ${mq.naiveMape.toFixed(1)}%`
            : 'Insufficient data for holdout'}
      </div>
    </div>
    <div class="kpi-card ${badge}">
      <div class="kpi-label">${confLabel}</div>
      <div class="kpi-value">${conf}%</div>
      <div class="kpi-sub ${badge}">
        ${badge==='green'?'â— High':badge==='amber'?'â— Moderate':'â— Low'}
        ${mq.confEstimated ? ' (estimated)' : ''}
      </div>
    </div>
  `;

  // â”€â”€ SCENARIO TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fcstPeriodLabels = Array.from({length: horizon}, (_, i) => `F${i+1}`);
  $('scenarioDivider').textContent = `Scenario Analysis â€” ${horizon}-Period Outlook`;
  $('scenarioHeader').innerHTML =
    `<div class="scenario-header-cell"></div>` +
    fcstPeriodLabels.map(l => `<div class="scenario-header-cell">${l}</div>`).join('');

  const makeDelta = (v, ref) => {
    const d = ((v - ref) / Math.abs(ref) * 100).toFixed(1);
    return `${d >= 0 ? '+' : ''}${d}%`;
  };

  $('scenarioRows').innerHTML = [
    { cls:'opt',  label:'â–² Optimistic',  vals: opt  },
    { cls:'base', label:'â—† Base',        vals: base },
    { cls:'pess', label:'â–¼ Pessimistic', vals: pess },
  ].map(row =>
    `<div class="scenario-row ${row.cls}">
      <div class="scenario-label-cell">${row.label}</div>
      ${row.vals.map(v =>
        `<div class="scenario-value-cell">
          <div class="val">${fmtNum(v)}</div>
          <div class="delta">${makeDelta(v, lastActual)}</div>
        </div>`).join('')}
    </div>`
  ).join('');

  // â”€â”€ ENHANCED LOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ts = new Date().toLocaleTimeString();
  $('logOutput').innerHTML =
    `<span class="log-ok">[${ts}] âœ“ Analysis complete Â· EMA Î±=${alpha} Â· horizon=${horizon}</span>\n` +
    `<span class="log-info">[INFO] Metric         : ${metric}</span>\n` +
    `<span class="log-info">[INFO] Data points    : ${s.length} (tail for slope: last ${tailLen})</span>\n` +
    `<span class="log-info">[INFO] Average        : ${avg.toFixed(4)}</span>\n` +
    `<span class="log-info">[INFO] Std Dev        : ${sigma.toFixed(4)}</span>\n` +
    `<span class="log-info">[INFO] Volatility     : ${(vol*100).toFixed(2)}%</span>\n` +
    `<span class="log-info">[INFO] EMA Slope      : ${slope.toFixed(6)}</span>\n` +
    `<span class="log-info">[INFO] RÂ² (smoother)  : ${r2.toFixed(4)} â€” fit only, not predictive</span>\n` +
    (holdout
      ? `<span class="log-info">[HOLD] Split          : train=${s.length - holdout.holdoutSize}, test=${holdout.holdoutSize} (25% holdout)</span>\n` +
        `<span class="log-info">[HOLD] EMA MAPE       : ${holdout.holdoutMape.toFixed(2)}% (out-of-sample)</span>\n` +
        `<span class="log-info">[HOLD] Naive MAPE     : ${holdout.naiveMape.toFixed(2)}% (last-value baseline)</span>\n` +
        `<span class="log-${holdout.holdoutMape < holdout.naiveMape ? 'ok' : 'warn'}">[HOLD] vs Naive       : EMA ${holdout.holdoutMape < holdout.naiveMape ? 'wins' : 'loses/ties'} (Î”MAPE=${(holdout.naiveMape - holdout.holdoutMape).toFixed(2)}%)</span>\n` +
        `<span class="log-info">[HOLD] Directional    : ${holdout.holdoutDirAcc.toFixed(1)}% (holdout)</span>\n`
      : `<span class="log-warn">[HOLD] Skipped        : < 8 points â€” no holdout split possible</span>\n` +
        `<span class="log-warn">[HOLD] MAPE shown     : in-sample approximation â€” interpret cautiously</span>\n`
    ) +
    `<span class="log-info">[INFO] Directional    : ${inSampleDirAcc.toFixed(1)}% (full series)</span>\n` +
    `<span class="log-info">[INFO] Max Drawdown   : ${maxDD.toFixed(2)}%</span>\n` +
    (mq.seasonality ? `<span class="log-warn">[SEAS] Detected       : ${mq.seasonality.period}-period cycle (r=${mq.seasonality.strength.toFixed(2)})</span>\n` : '') +
    (mq.outliers.length > 0 ? `<span class="log-warn">[DATA] Outliers       : ${mq.outliers.map(o => `#${o.index}=${o.value.toFixed(1)}`).join(', ')}</span>\n` : '') +
    `<span class="log-info">[INFO] Î” Next period  : ${pctSign}${pctChange}%</span>\n` +
    `<span class="log-${badge}">[CONF] Score          : ${conf}%${confEstimated ? ' (estimated â€” small sample)' : ' (holdout-grounded)'} â†’ ${badge.toUpperCase()}</span>\n` +
    base.map((v, i) => `<span class="log-info">[FCST] Base[+${i+1}]    : ${v.toFixed(4)}</span>`).join('\n') + '\n' +
    `<span class="log-ok">[FCST] Opt [+1]    : ${opt[0].toFixed(4)}</span>\n` +
    `<span class="log-warn">[FCST] Pess[+1]   : ${pess[0].toFixed(4)}</span>`;

  [$('kpiSection'), $('chartSection'), $('scenarioSection'), $('logSection')]
    .forEach(el => el.classList.remove('hidden'));
  pdfBtn.disabled = false; csvExportBtn.disabled = false;

  renderChart(s, smooth, base, opt, pess, labels);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHART
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildChartConfig(s, t, b, o, p, labels, theme='dark', fontScale=1) {
  const isDark = theme === 'dark', isPDF = fontScale > 1;
  const gridColor = isDark ? 'rgba(30,34,48,0.8)' : 'rgba(190,200,215,0.7)';
  const tickColor = isDark ? '#6b7280' : '#334155';
  const ttBg = isDark ? '#11131c' : '#ffffff';
  const ttBorder = isDark ? '#1e2230' : '#cbd5e1';
  const ttTitle = isDark ? '#e8e9ef' : '#0f172a';
  const ttBody  = isDark ? '#6b7280' : '#475569';
  const lineWidth = isPDF ? 5 : 2, emaWidth = isPDF ? 3.5 : 1.5;
  const pointR = isPDF ? 7 : 3, fcstPtR = isPDF ? 9 : 4;
  const tickSz = Math.round(9 * fontScale), legendSz = Math.round(10 * fontScale);
  const fullLabels = [...labels.slice(0, s.length), ...b.map((_,i) => `F${i+1}`)];
  const yTickCb = val => {
    if (Math.abs(val) >= 1e6) return (val/1e6).toFixed(1)+'M';
    if (Math.abs(val) >= 1e3) return (val/1e3).toFixed(1)+'K';
    if (Math.abs(val) < 0.01 && val !== 0) return val.toExponential(1);
    return val.toFixed(val % 1 === 0 ? 0 : 2);
  };
  return {
    type: 'line',
    data: {
      labels: fullLabels,
      datasets: [
        { label:'Actual', data:s, borderColor:'#c9a84c', backgroundColor:'rgba(201,168,76,0.10)',
          borderWidth:lineWidth, tension:0.3, pointRadius:pointR,
          pointBackgroundColor:'#c9a84c', pointBorderColor:'#ffffff',
          pointBorderWidth:isPDF?2:1, fill:true },
        { label:'EMA Trend', data:t, borderColor:'#4c8ec9', borderWidth:emaWidth,
          borderDash:isPDF?[12,8]:[4,4], tension:0.4, pointRadius:0, fill:false },
        { label:'Base Forecast', data:[...Array(s.length).fill(null), ...b],
          borderColor:'#c9a84c', borderWidth:lineWidth, borderDash:isPDF?[16,8]:[6,6],
          pointRadius:fcstPtR, pointBackgroundColor:'#c9a84c', pointBorderColor:'#ffffff',
          pointBorderWidth:isPDF?2:1, fill:false },
        { label:'Upper (Opt.)', data:[...Array(s.length).fill(null), ...o],
          borderColor:'#22c55e', borderWidth:isPDF?3:0,
          backgroundColor:'rgba(34,197,94,0.13)', fill:'+1', pointRadius:0 },
        { label:'Lower (Pess.)', data:[...Array(s.length).fill(null), ...p],
          borderColor:'#ef4444', borderWidth:isPDF?3:0, fill:false, pointRadius:0 },
      ]
    },
    options: {
      responsive:!isPDF, maintainAspectRatio:false,
      animation:{duration:0}, interaction:{mode:'index', intersect:false},
      layout:{ padding:{ top:isPDF?30:10, right:isPDF?50:10, bottom:isPDF?10:5, left:isPDF?10:5 } },
      plugins: {
        legend:{ display:true, labels:{ color:isDark?'#9ca3af':'#334155',
          font:{family:'monospace', size:legendSz}, boxWidth:isPDF?50:20, padding:isPDF?30:10 } },
        tooltip:{ enabled:!isPDF, backgroundColor:ttBg, borderColor:ttBorder, borderWidth:1,
          titleColor:ttTitle, bodyColor:ttBody,
          titleFont:{family:'monospace',size:11}, bodyFont:{family:'monospace',size:10} }
      },
      scales: {
        x:{ grid:{color:gridColor, lineWidth:isPDF?1.5:1},
            border:{color:isDark?'#374151':'#64748b', width:isPDF?2:1},
            ticks:{color:tickColor, font:{family:'monospace',size:tickSz, weight:isPDF?'700':'400'},
              maxTicksLimit:isPDF?10:14, maxRotation:isPDF?45:0, minRotation:isPDF?30:0} },
        y:{ grid:{color:gridColor, lineWidth:isPDF?1.5:1},
            border:{color:isDark?'#374151':'#64748b', width:isPDF?2:1},
            ticks:{color:tickColor, font:{family:'monospace',size:tickSz, weight:isPDF?'700':'400'},
              callback:yTickCb, maxTicksLimit:8} }
      }
    }
  };
}

function renderChart(s, t, b, o, p, labels) {
  if (chartObj) { chartObj.destroy(); chartObj = null; }
  chartObj = new Chart($('trendChart').getContext('2d'),
    buildChartConfig(s, t, b, o, p, labels, 'dark'));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT CSV
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function exportForecastCSV() {
  if (!lastAnalysis) return;
  const { metric, base, opt, pess } = lastAnalysis;
  const lines = ['period,scenario,value'];
  base.forEach((v, i) => {
    lines.push(`+${i+1},optimistic,${opt[i].toFixed(4)}`);
    lines.push(`+${i+1},base,${v.toFixed(4)}`);
    lines.push(`+${i+1},pessimistic,${pess[i].toFixed(4)}`);
  });
  const blob = new Blob([lines.join('\n')], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = `${metric}_forecast.csv`;
  a.click(); URL.revokeObjectURL(a.href);
  toast('âœ“ Forecast CSV downloaded');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT PDF
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function exportPDF() {
  if (!lastAnalysis) return;
  if (!window.jspdf) { toast('PDF library not loaded â€” try again', true); return; }
  pdfBtn.disabled = true; pdfBtn.textContent = 'Building PDF...';

  const { metric, s, smooth, labels, base, opt, pess, avg, sigma,
          slope, conf, r2, trendDir, pctChange, pctSign, modelQuality: mq } = lastAnalysis;

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation:'portrait', unit:'mm', format:'a4' });
  const PW = 210, ML = 12, MR = 12, CW = PW - ML - MR;
  let Y = 0;

  const rgb  = hex => [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
  const fill = hex => { const [r,g,b] = rgb(hex); doc.setFillColor(r,g,b); };
  const draw = hex => { const [r,g,b] = rgb(hex); doc.setDrawColor(r,g,b); };
  const text = hex => { const [r,g,b] = rgb(hex); doc.setTextColor(r,g,b); };
  const FR   = (x,y,w,h) => doc.rect(x,y,w,h,'F');
  const DR   = (x,y,w,h) => doc.rect(x,y,w,h,'S');
  const LN   = (x1,y1,x2,y2) => doc.line(x1,y1,x2,y2);

  const isHigh = conf > 72, isMid = conf > 50;
  const badgeHex   = isHigh ? '#15803d' : isMid ? '#b45309' : '#b91c1c';
  const badgeBg    = isHigh ? '#f0fdf4' : isMid ? '#fffbeb' : '#fef2f2';
  const badgeLabel = isHigh ? 'HIGH CONFIDENCE' : isMid ? 'MODERATE CONFIDENCE' : 'LOW CONFIDENCE';
  const lastActual = s[s.length - 1];

  let chartImg = null;
  try {
    const pdfCanvas = $('pdfChartCanvas');
    pdfCanvas.width = 1600; pdfCanvas.height = 560;
    if (window._pdfChartObj) { try { window._pdfChartObj.destroy(); } catch(e){} window._pdfChartObj = null; }
    window._pdfChartObj = new Chart(pdfCanvas.getContext('2d'),
      buildChartConfig(s, smooth, base, opt, pess, labels, 'light', 3.5));
    await new Promise(resolve => requestAnimationFrame(() => setTimeout(resolve, 220)));
    const tmp = document.createElement('canvas');
    tmp.width = pdfCanvas.width; tmp.height = pdfCanvas.height;
    const ctx2 = tmp.getContext('2d');
    ctx2.fillStyle = '#ffffff'; ctx2.fillRect(0,0,tmp.width,tmp.height);
    ctx2.drawImage(pdfCanvas, 0, 0);
    chartImg = tmp.toDataURL('image/png', 0.95);
    window._pdfChartObj.destroy(); window._pdfChartObj = null;
  } catch(e) { console.warn('Chart capture failed:', e); }

  // Header
  fill('#0d1117'); FR(0,0,PW,30);
  fill('#c9a84c'); FR(0,30,PW*0.5,2.5);
  fill('#4c8ec9'); FR(PW*0.5,30,PW*0.5,2.5);
  doc.setFont('helvetica','bold'); doc.setFontSize(20); text('#ffffff');
  doc.text('PARAGON', ML, 18);
  doc.setFont('helvetica','normal'); doc.setFontSize(6.5); text('#c9a84c');
  doc.text('ANALYTICS  -  EXECUTIVE FORECASTING REPORT', ML, 25);
  text('#9ca3af');
  doc.text('CONFIDENTIAL', PW-MR, 17, {align:'right'});
  text('#e5e7eb');
  doc.text(new Date().toLocaleDateString('en-US',{year:'numeric',month:'long',day:'numeric'}), PW-MR, 24, {align:'right'});

  Y = 39;
  doc.setFont('helvetica','normal'); doc.setFontSize(6.5); text('#9ca3af');
  doc.text('ANALYSIS SUBJECT', ML, Y); Y += 5;
  const title = metric.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
  doc.setFont('helvetica','bold'); doc.setFontSize(17); text('#111111');
  doc.text(title, ML, Y);
  const pillTxt = `${conf}%  ${badgeLabel}${mq.confEstimated?' (est.)':''}`;
  doc.setFont('helvetica','bold'); doc.setFontSize(6.5);
  const pillW = doc.getTextWidth(pillTxt) + 6;
  fill(badgeBg); FR(PW-MR-pillW, Y-6, pillW, 8);
  draw(badgeHex); doc.setLineWidth(0.25); DR(PW-MR-pillW, Y-6, pillW, 8);
  text(badgeHex); doc.text(pillTxt, PW-MR-pillW+3, Y-0.5);
  Y += 5;
  doc.setFont('helvetica','normal'); doc.setFontSize(7.5); text('#6b7280');
  const mapeDesc = mq.mapeIsHoldout ? `Holdout MAPE: ${mq.mape.toFixed(1)}%  (n=${mq.holdoutSize} held out)` : `MAPE: ${mq.mape.toFixed(1)}% (in-sample approx.)`;
  doc.text(`${s.length} data points   EMA Î± = ${alpha.toFixed(2)}   Horizon = ${horizon}   ${mapeDesc}`, ML, Y);
  Y += 3;
  draw('#cccccc'); doc.setLineWidth(0.4); LN(ML, Y, PW-MR, Y); Y += 6;

  // KPI boxes
  const kpis = [
    { label:'AVERAGE',    value:fmtNum(avg),    sub:'Historical mean',   color:'#2563eb' },
    { label:mq.mapeIsHoldout?'HOLDOUT MAPE':'MAPE (est.)',
                          value:mq.mape.toFixed(1)+'%',
                                                sub:mq.mapeIsHoldout?'Out-of-sample':'In-sample only',
                                                color:mq.mape<10?'#16a34a':mq.mape<20?'#ca8a04':'#dc2626' },
    { label:'DIRECTIONAL',value:mq.directionalAccuracy.toFixed(0)+'%',
                                                sub:'Trend accuracy',    color:'#0891b2' },
    { label:'MAX DRAWDOWN',value:mq.maxDrawdown.toFixed(1)+'%',
                                                sub:'Peak-to-trough',   color:mq.maxDrawdown<10?'#16a34a':mq.maxDrawdown<25?'#ca8a04':'#dc2626' },
    { label:'RÂ² SMOOTH',  value:r2.toFixed(3),  sub:'Fit only, not pred.',color:'#7c3aed' },
    { label:'CONFIDENCE', value:conf+'%',        sub:badgeLabel,         color:badgeHex  },
  ];
  const GAP=2.5, BOX_W=(CW-GAP*5)/6, BOX_H=20;
  kpis.forEach((k,i) => {
    const bx=ML+i*(BOX_W+GAP), by=Y;
    fill('#f8fafc'); FR(bx,by,BOX_W,BOX_H);
    draw('#e2e8f0'); doc.setLineWidth(0.25); DR(bx,by,BOX_W,BOX_H);
    fill(k.color); FR(bx,by,BOX_W,1.8);
    doc.setFont('helvetica','normal'); doc.setFontSize(5); text('#94a3b8');
    doc.text(k.label, bx+BOX_W/2, by+6.5, {align:'center'});
    doc.setFont('helvetica','bold');
    doc.setFontSize(k.value.length>10?8.5:11); text(k.color);
    doc.text(k.value, bx+BOX_W/2, by+13, {align:'center'});
    doc.setFont('helvetica','normal'); doc.setFontSize(4.8); text('#94a3b8');
    doc.text(doc.splitTextToSize(k.sub,BOX_W-2)[0], bx+BOX_W/2, by+17.5, {align:'center'});
  });
  Y += BOX_H+7;

  // Chart
  doc.setFont('helvetica','normal'); doc.setFontSize(6); text('#9ca3af');
  doc.text('TREND & FORECAST CHART', ML, Y); Y += 3;
  const CHART_H = 75;
  if (chartImg) {
    fill('#ffffff'); FR(ML,Y,CW,CHART_H);
    draw('#e2e8f0'); doc.setLineWidth(0.3); DR(ML,Y,CW,CHART_H);
    doc.addImage(chartImg,'PNG',ML+1.5,Y+1.5,CW-3,CHART_H-3);
  } else {
    fill('#f8fafc'); FR(ML,Y,CW,CHART_H);
    draw('#e2e8f0'); doc.setLineWidth(0.3); DR(ML,Y,CW,CHART_H);
    doc.setFont('helvetica','normal'); doc.setFontSize(8); text('#9ca3af');
    doc.text('Chart not available', ML+CW/2, Y+CHART_H/2, {align:'center'});
  }
  Y += CHART_H+5;

  // Stats strip
  const stats = [
    {label:'DATA POINTS', val:String(s.length)},
    {label:'MINIMUM',     val:fmtNum(Math.min(...s))},
    {label:'MAXIMUM',     val:fmtNum(Math.max(...s))},
    {label:'LAST ACTUAL', val:fmtNum(lastActual)},
    {label:'EMA (LAST)',  val:fmtNum(smooth[smooth.length-1])},
    {label:'SLOPE',       val:slope.toFixed(4)},
  ];
  const STAT_W=CW/stats.length, STAT_H=10;
  stats.forEach((st,i) => {
    const sx=ML+i*STAT_W;
    fill(i%2===0?'#f8fafc':'#f1f5f9'); FR(sx,Y,STAT_W,STAT_H);
    draw('#e2e8f0'); doc.setLineWidth(0.2); DR(sx,Y,STAT_W,STAT_H);
    doc.setFont('helvetica','normal'); doc.setFontSize(4.8); text('#94a3b8');
    doc.text(st.label, sx+STAT_W/2, Y+3.8, {align:'center'});
    doc.setFont('helvetica','bold'); doc.setFontSize(7); text('#1e293b');
    doc.text(st.val, sx+STAT_W/2, Y+8, {align:'center'});
  });
  Y += STAT_H+7;

  // Scenario table
  doc.setFont('helvetica','normal'); doc.setFontSize(6); text('#9ca3af');
  doc.text(`${horizon}-PERIOD SCENARIO FORECAST`, ML, Y); Y += 3;
  const scenarios = [
    {label:'OPTIMISTIC',  tag:'(+1 SD)', vals:opt,  bg:'#f0fdf4', color:'#15803d', border:'#86efac'},
    {label:'BASE CASE',   tag:'(EMA)',   vals:base, bg:'#fffbeb', color:'#92400e', border:'#fcd34d'},
    {label:'PESSIMISTIC', tag:'(-1 SD)', vals:pess, bg:'#fef2f2', color:'#b91c1c', border:'#fca5a5'},
  ];
  const COLS=horizon+1, COL_W=CW/COLS, ROW_H=13, TBL_X=ML;
  fill('#0d1117'); FR(TBL_X,Y,CW,ROW_H*0.85);
  doc.setFont('helvetica','bold'); doc.setFontSize(6.5); text('#ffffff');
  doc.text('SCENARIO', TBL_X+COL_W*0.5, Y+5.5, {align:'center'});
  for (let i=0;i<horizon;i++) doc.text(`PERIOD +${i+1}`, TBL_X+COL_W*(i+1)+COL_W*0.5, Y+5.5, {align:'center'});
  Y += ROW_H*0.85;

  scenarios.forEach(row => {
    fill(row.bg); FR(TBL_X,Y,CW,ROW_H);
    fill(row.color); FR(TBL_X,Y,2,ROW_H);
    draw(row.border); doc.setLineWidth(0.3); LN(TBL_X,Y+ROW_H,TBL_X+CW,Y+ROW_H);
    doc.setFont('helvetica','bold'); doc.setFontSize(7.5); text(row.color);
    doc.text(row.label, TBL_X+COL_W*0.5, Y+6.5, {align:'center'});
    doc.setFont('helvetica','normal'); doc.setFontSize(5.5); text('#94a3b8');
    doc.text(row.tag, TBL_X+COL_W*0.5, Y+10.5, {align:'center'});
    row.vals.forEach((v,i) => {
      const cx=TBL_X+COL_W*(i+1)+COL_W*0.5;
      doc.setFont('helvetica','bold'); doc.setFontSize(9.5); text(row.color);
      doc.text(fmtNum(v), cx, Y+6.5, {align:'center'});
      const delta=lastActual!==0?((v-lastActual)/Math.abs(lastActual)*100).toFixed(1):'â€”';
      doc.setFont('helvetica','normal'); doc.setFontSize(5.5); text('#94a3b8');
      doc.text(`${parseFloat(delta)>=0?'+':''}${delta}% vs last`, cx, Y+10.5, {align:'center'});
    });
    draw('#e2e8f0'); doc.setLineWidth(0.2);
    for (let i=1;i<=horizon;i++) LN(TBL_X+COL_W*i,Y,TBL_X+COL_W*i,Y+ROW_H);
    Y += ROW_H;
  });
  draw('#cbd5e1'); doc.setLineWidth(0.4); DR(TBL_X,Y-ROW_H*3,CW,ROW_H*3);

  // Footer
  fill('#0d1117'); FR(0,282,PW,15);
  doc.setFont('helvetica','normal'); doc.setFontSize(6); text('#6b7280');
  doc.text('Paragon Analytics  -  Executive Forecasting  -  For internal use only', ML, 288);
  doc.text(`paragon.analytics  -  ${new Date().getFullYear()}`, PW-MR, 288, {align:'right'});
  text('#c9a84c'); doc.text('CONFIDENTIAL', PW/2, 292, {align:'center'});

  doc.save(`paragon_${metric.replace(/\W+/g,'_').toLowerCase()}_report.pdf`);
  pdfBtn.disabled = false; pdfBtn.textContent = 'â¬‡ Export PDF';
  toast('PDF downloaded successfully');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toast(msg, err=false) {
  const t = $('toast'); t.textContent = msg;
  t.className = err ? 'show err' : 'show';
  clearTimeout(t._tid); t._tid = setTimeout(() => { t.className = ''; }, 3200);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
loadSettings();
</script>
</body>
</html>
