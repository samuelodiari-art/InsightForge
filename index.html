<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PARAGON ANALYTICS</title>

<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body {
  background: radial-gradient(circle at top, #14002a, #050012);
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
  margin:0;
}
button, select {
  padding: 10px;
  margin: 5px;
  border-radius: 6px;
  border: none;
  font-weight: bold;
}
.primary { background: gold; color:black; }
.secondary { background: #333; color:white; }
.panel { max-width:1200px; margin:auto; padding:10px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:10px; }
.card { background:rgba(255,255,255,0.08); padding:10px; border-radius:10px; }
.value { font-size:18px; font-weight:bold; }
canvas { background:rgba(255,255,255,0.05); border-radius:10px; margin-top:15px; }
textarea { width:95%; height:140px; border-radius:8px; padding:8px; }
</style>
</head>

<body>

<h2>PARAGON ANALYTICS</h2>
<p>Automated Business Intelligence Platform</p>

<input type="file" id="csvFile"><br>

<select id="metricSelect">
  <option value="Revenue">Revenue</option>
  <option value="Profit">Profit</option>
  <option value="Cost">Cost</option>
  <option value="UnitsSold">Units Sold</option>
</select>

<select id="aggregationSelect">
  <option value="raw">Raw</option>
  <option value="week">Weekly</option>
  <option value="month" selected>Monthly</option>
  <option value="quarter">Quarterly</option>
</select>

<br>
<button class="primary" onclick="loadCSV()">Load CSV</button>
<button class="secondary" onclick="runAnalytics()">Run Intelligence</button>
<button class="secondary" onclick="exportPDF()">Export PDF</button>

<div class="panel">
  <canvas id="lineChart"></canvas>
  <canvas id="kpiChart"></canvas>
  <canvas id="productChart"></canvas>

  <h3>Risk & Accuracy</h3>
  <div class="grid" id="riskPanel"></div>

  <h3>Scenario Forecast</h3>
  <div class="grid" id="scenarioPanel"></div>

  <h3>AI Insights Ranking</h3>
  <textarea id="aiText"></textarea>
</div>

<script>
let rawRows = [];
let headers = [];
let charts = {}, cache = {};

/* ================= LOAD CSV ================= */

function loadCSV(){
  const file = csvFile.files[0];
  if(!file) return alert("Upload CSV first.");

  const reader = new FileReader();
  reader.onload = e => {
    const lines = e.target.result.trim().split("\n");
    headers = lines[0].split(",").map(h=>h.trim());
    rawRows = lines.slice(1).map(r=>r.split(","));
    alert("CSV Loaded Successfully");
  };
  reader.readAsText(file);
}

/* ================= MAIN ENGINE ================= */

function runAnalytics(){
  if(!rawRows.length) return alert("Load CSV first.");

  const metric = metricSelect.value;
  const agg = aggregationSelect.value;

  const colIndex = headers.indexOf(metric);
  const dateIndex = headers.indexOf("Date");
  const productIndex = headers.indexOf("Product");

  if(colIndex === -1 || dateIndex === -1 || productIndex === -1){
    return alert("CSV must contain Date, Product and " + metric + " columns.");
  }

  const parsed = rawRows.map(r=>({
    date: new Date(r[dateIndex]),
    value: parseFloat(r[colIndex]),
    product: r[productIndex]
  })).filter(r=>isFinite(r.value) && !isNaN(r.date));

  const aggregated = aggregateData(parsed, agg);
  const values = aggregated.map(r=>r.value);
  const labels = aggregated.map(r=>r.label);

  const smooth = expSmooth(values,0.35);
  const forecast = forecastModel(smooth);
  const confidence = forecastConfidence(values,smooth);
  const risk = riskModel(values,confidence);
  const kpi = kpiCalc(values);
  const segments = segment(parsed.map(r=>r.product), parsed.map(r=>r.value));
  const scenarios = scenarioForecast(forecast);

  cache = {forecast,confidence,risk,kpi,segments,scenarios};

  renderLine(labels,values,smooth,forecast);
  renderBars(kpi,segments);
  renderRisk(risk,confidence);
  renderScenarios(scenarios);
  generateInsights();
}

/* ================= AGGREGATION ================= */

function aggregateData(data, mode){
  if(mode === "raw"){
    return data.map((d,i)=>({ label:"P"+(i+1), value:d.value }));
  }

  let map = {};
  data.forEach(d=>{
    let key;
    const dt = d.date;

    if(mode === "week") key = dt.getFullYear()+"-W"+getWeek(dt);
    if(mode === "month") key = dt.getFullYear()+"-"+(dt.getMonth()+1);
    if(mode === "quarter") key = dt.getFullYear()+"-Q"+(Math.floor(dt.getMonth()/3)+1);

    map[key] = (map[key] || 0) + d.value;
  });

  return Object.entries(map)
    .sort((a,b)=>a[0].localeCompare(b[0]))
    .map(([k,v])=>({ label:k, value:v }));
}

function getWeek(d){
  const onejan = new Date(d.getFullYear(),0,1);
  return Math.ceil((((d - onejan) / 86400000) + onejan.getDay()+1)/7);
}

/* ================= FORECAST ================= */

function expSmooth(data,a){
  let s=[data[0]];
  for(let i=1;i<data.length;i++){
    s.push(a*data[i] + (1-a)*s[i-1]);
  }
  return s;
}

function forecastModel(series){
  let lookback = Math.min(6, series.length-1);
  let trend = (series.at(-1) - series.at(-lookback)) / lookback;
  let base = series.at(-1);
  let vol = std(series) * 0.35;

  let baseF = [1,2,3].map(i=>Math.round(base + trend*i));
  return {
    base: baseF,
    upper: baseF.map(v=>Math.round(v + vol)),
    lower: baseF.map(v=>Math.round(v - vol))
  };
}

/* ================= CONFIDENCE ================= */

function forecastConfidence(actual, smooth){
  if(actual.length < 8) return "N/A";

  let meanVal = mean(actual);
  let ssTot = 0;
  let ssRes = 0;

  for(let i=1;i<actual.length;i++){
    ssTot += (actual[i] - meanVal) ** 2;
    ssRes += (actual[i] - smooth[i-1]) ** 2;
  }

  let r2 = 1 - (ssRes / (ssTot || 1));
  r2 = Math.max(-1, Math.min(1, r2));

  let confidence = 50 + (r2 * 50);
  confidence = Math.max(5, Math.min(100, confidence));

  return confidence.toFixed(1);
}

/* ================= RISK ================= */

function riskModel(data, confidence){
  let volatility = (std(data) / mean(data)) * 100;
  let riskScore = (volatility * 0.6) + ((100 - confidence) * 0.4);
  let level = riskScore > 55 ? "HIGH" : riskScore > 35 ? "MEDIUM" : "LOW";
  return {
    volatility: volatility.toFixed(1),
    riskScore: riskScore.toFixed(1),
    level
  };
}

/* ================= KPI ================= */

function kpiCalc(d){
  return {
    max: Math.max(...d),
    min: Math.min(...d),
    avg: Math.round(mean(d)),
    growth: (((d.at(-1) - d[0]) / Math.abs(d[0] || 1)) * 100).toFixed(1)
  };
}

/* ================= SEGMENT ================= */

function segment(p,v){
  let map={};
  p.forEach((x,i)=> map[x] = (map[x]||0) + v[i]);
  return Object.entries(map).sort((a,b)=>b[1]-a[1]);
}

/* ================= SCENARIO ================= */

function scenarioForecast(f){
  return {
    base: f.base,
    optimistic: f.base.map(v=>Math.round(v*1.12)),
    conservative: f.base.map(v=>Math.round(v*0.88))
  };
}

/* ================= INSIGHTS ================= */

function generateInsights(){
  let c = cache;
  aiText.value =
`INSIGHTS RANKING

1. Forecast Confidence: ${c.confidence}% 
2. Risk Level: ${c.risk.level} (Volatility ${c.risk.volatility}%)
3. Growth Rate: ${c.kpi.growth}%
4. Top Product: ${c.segments[0][0]}
5. Scenario Risk Spread: ${(c.scenarios.optimistic[0] - c.scenarios.conservative[0]).toLocaleString()}

RECOMMENDATIONS
- Use conservative scenario for budgeting.
- Scale cautiously under ${c.risk.level} risk.
- Strengthen inventory for ${c.segments[0][0]}.
- Monitor volatility trend monthly.`;
}

/* ================= CHARTS ================= */

function renderLine(labels,actual,smooth,f){
  destroy("line");
  charts.line = new Chart(lineChart,{
    type:"line",
    data:{
      labels:[...labels,"F1","F2","F3"],
      datasets:[
        {label:"Actual",data:actual},
        {label:"Smoothed",data:smooth,borderDash:[5,5]},
        {label:"Forecast",data:[...Array(actual.length).fill(null),...f.base],borderDash:[3,3]},
        {label:"Upper Band",data:[...Array(actual.length).fill(null),...f.upper],borderDash:[2,4]},
        {label:"Lower Band",data:[...Array(actual.length).fill(null),...f.lower],borderDash:[2,4]}
      ]
    }
  });
}

function renderBars(kpi,segments){
  destroy("kpi"); destroy("prod");

  charts.kpi = new Chart(kpiChart,{
    type:"bar",
    data:{ labels:["Max","Min","Avg","Growth%"], datasets:[{data:[kpi.max,kpi.min,kpi.avg,kpi.growth]}] }
  });

  charts.prod = new Chart(productChart,{
    type:"bar",
    data:{ labels:segments.map(s=>s[0]), datasets:[{data:segments.map(s=>s[1])}] }
  });
}

function destroy(n){ if(charts[n]) charts[n].destroy(); }

/* ================= UI ================= */

function renderRisk(r,c){
  riskPanel.innerHTML = `
  <div class="card">Volatility<div class="value">${r.volatility}%</div></div>
  <div class="card">Confidence<div class="value">${c}%</div></div>
  <div class="card">Risk Score<div class="value">${r.riskScore}</div></div>
  <div class="card">Risk Level<div class="value">${r.level}</div></div>`;
}

function renderScenarios(s){
  scenarioPanel.innerHTML = `
  <div class="card">Base<div class="value">${s.base.join(", ")}</div></div>
  <div class="card">Optimistic<div class="value">${s.optimistic.join(", ")}</div></div>
  <div class="card">Conservative<div class="value">${s.conservative.join(", ")}</div></div>`;
}

/* ================= MULTI-PAGE PDF EXPORT ================= */

async function exportPDF(){
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF("p","mm","a4");

  const margin = 12;
  const pageWidth = 210 - margin*2;
  const imgHeight = 90;

  function title(t){
    pdf.setFontSize(16);
    pdf.text(t, margin, 18);
  }

  function subtitle(t){
    pdf.setFontSize(11);
    pdf.text(t, margin, 28);
  }

  /* PAGE 1 — SUMMARY */
  title("PARAGON ANALYTICS REPORT");
  subtitle(`Risk: ${cache.risk.level} | Forecast Confidence: ${cache.confidence}%`);

  pdf.setFontSize(11);
  pdf.text("Executive Insights:", margin, 45);
  pdf.setFontSize(10);
  pdf.text(aiText.value, margin, 55, { maxWidth: 180 });

  /* PAGE 2 — FORECAST */
  pdf.addPage();
  title("Forecast Analysis");
  pdf.addImage(lineChart.toDataURL("image/png"),"PNG",margin,40,pageWidth,imgHeight);

  /* PAGE 3 — KPI */
  pdf.addPage();
  title("KPI Summary");
  pdf.addImage(kpiChart.toDataURL("image/png"),"PNG",margin,40,pageWidth,imgHeight);

  /* PAGE 4 — PRODUCT */
  pdf.addPage();
  title("Product Segmentation");
  pdf.addImage(productChart.toDataURL("image/png"),"PNG",margin,40,pageWidth,imgHeight);

  /* PAGE 5 — RISK */
  pdf.addPage();
  title("Risk & Scenario Summary");
  pdf.setFontSize(11);
  pdf.text(`Volatility: ${cache.risk.volatility}%`, margin, 45);
  pdf.text(`Risk Score: ${cache.risk.riskScore}`, margin, 55);
  pdf.text(`Risk Level: ${cache.risk.level}`, margin, 65);
  pdf.text(`Forecast Confidence: ${cache.confidence}%`, margin, 75);

  pdf.text("Scenario Forecast:", margin, 95);
  pdf.text(`Base: ${cache.scenarios.base.join(", ")}`, margin, 105);
  pdf.text(`Optimistic: ${cache.scenarios.optimistic.join(", ")}`, margin, 115);
  pdf.text(`Conservative: ${cache.scenarios.conservative.join(", ")}`, margin, 125);

  pdf.save("paragon_report.pdf");
}

/* ================= MATH ================= */

function mean(a){ return a.reduce((x,y)=>x+y,0)/a.length; }
function std(a){ let m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)**2))); }

</script>
</body>
  </html>
