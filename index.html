<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PARAGON ANALYTICS v2.1</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body {
  background: radial-gradient(circle at top, #16002e, #050012);
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
}
button, select {
  padding: 10px;
  margin: 5px;
  border-radius: 6px;
  border: none;
  font-weight: bold;
}
.primary { background: gold; color:black; }
.secondary { background: #333; color:white; }
.panel { max-width:1200px; margin:auto; padding:10px; }
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:10px; }
.card { background:rgba(255,255,255,0.08); padding:10px; border-radius:10px; }
.value { font-size:18px; font-weight:bold; }
canvas { background:rgba(255,255,255,0.06); border-radius:10px; margin-top:15px; }
.badge {
  display:inline-block;
  padding:6px 14px;
  border-radius:20px;
  font-weight:bold;
  margin:10px;
}
.VALIDATED{background:#00c853;}
.STABLE{background:#4caf50;}
.MONITOR{background:#ffc107;color:black;}
.UNSTABLE{background:#e53935;}
</style>
</head>

<body>

<h2>PARAGON ANALYTICS v2.1</h2>
<p>Production-Grade Autonomous Business Intelligence Engine</p>

<input type="file" id="csvFile"><br>

<select id="metricSelect">
  <option>Revenue</option>
  <option>Cost</option>
  <option>Profit</option>
  <option>Units</option>
</select>

<br>
<button class="primary" onclick="loadCSV()">Load CSV</button>
<button class="secondary" onclick="runAnalytics()">Run Intelligence</button>
<button class="secondary" onclick="exportPDF()">Export PDF</button>

<div id="statusBadge"></div>

<div class="panel">
<canvas id="lineChart"></canvas>
<canvas id="bandChart"></canvas>
<canvas id="kpiChart"></canvas>
<canvas id="productPie"></canvas>
<canvas id="financialPie"></canvas>
<canvas id="confidenceChart"></canvas>

<h3>Top Insights</h3>
<div class="grid" id="insightPanel"></div>

<h3>Risk & Intelligence</h3>
<div class="grid" id="riskPanel"></div>

<h3>Scenario Forecast</h3>
<div class="grid" id="scenarioPanel"></div>
</div>

<script>
let rawRows=[], headers={}, charts={}, confidenceHistory=[], parsedCache=[];

/* ---------------- SECURITY & SANITIZATION ---------------- */

const safeNum = v => {
  if(v === null || v === undefined) return null;
  let x = String(v).replace(/[,$₦£€\s]/g,"");
  if(/^[=+\-@]/.test(x)) return null;
  let n = parseFloat(x);
  return isFinite(n) ? n : null;
};

const mean = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0;
const std  = a => {
  if(a.length<2) return 0;
  let m = mean(a);
  return Math.sqrt(mean(a.map(x=>(x-m)**2)));
};

/* ---------------- CSV LOADER ---------------- */

function loadCSV(){
  const file = csvFile.files[0];
  if(!file) return alert("Upload CSV first.");
  const reader = new FileReader();
  reader.onload = e => {
    const rows = e.target.result.trim().split("\n").map(r=>r.split(","));
    headers = {};
    rows[0].forEach((h,i)=>{
      headers[h.toLowerCase().replace(/\W/g,"")] = i;
    });
    rawRows = rows.slice(1);
    alert("CSV Loaded Successfully");
  };
  reader.readAsText(file);
}

/* ---------------- MAIN ENGINE ---------------- */

function runAnalytics(){
  if(!rawRows.length) return alert("Load CSV first.");

  const metric = metricSelect.value.toLowerCase();
  const metricKey = Object.keys(headers).find(h=>h.includes(metric));
  if(!metricKey) return alert("Metric column not detected.");

  const dateIndex = headers["date"] ?? 0;
  const productIndex = headers["product"] ?? null;
  const valueIndex = headers[metricKey];

  let parsed = rawRows.map(r=>{
    return {
      date: new Date(r[dateIndex]),
      value: safeNum(r[valueIndex]),
      product: productIndex!==null ? (r[productIndex]||"Unknown") : "All"
    };
  }).filter(r=>r.value!==null && !isNaN(r.date));

  if(parsed.length < 8) return alert("Not enough clean data.");

  parsedCache = parsed;

  const values = parsed.map(r=>r.value);
  const forecast = generateForecast(values);
  const bands = computeBands(values, forecast);

  const volatility = computeVolatility(values);
  const growth = computeGrowth(values);
  const seasonality = computeSeasonality(parsed);
  const mape = Math.min(60, volatility*0.6);

  const confidence = Math.max(40,
    100 - volatility*0.5 - mape*0.4 + seasonality*0.3
  );

  confidenceHistory.push(confidence);

  const status = computeStatus(confidence,mape,values.length,volatility);

  renderStatus(status);
  renderCharts(parsed, values, forecast, bands);
  renderInsights(confidence,mape,seasonality,volatility,growth,status);
  renderRisk(confidence,mape,seasonality,volatility);
  renderScenario(forecast);
  renderConfidence();
}

/* ---------------- VALIDATION ENGINE ---------------- */

function computeStatus(conf,mape,len,vol){
  if(len<12 || vol>55) return "UNSTABLE";
  if(conf>82 && mape<18) return "VALIDATED";
  if(conf>65) return "STABLE";
  return "MONITOR";
}

function renderStatus(s){
  statusBadge.innerHTML = `<div class="badge ${s}">${s}</div>`;
}

/* ---------------- METRICS ---------------- */

function computeGrowth(d){
  if(d.length<2) return 0;
  let base = Math.abs(d[0]) || 1;
  return ((d.at(-1)-d[0]) / base) * 100;
}

function computeSeasonality(data){
  let m={};
  data.forEach(d=>{
    let k=d.date.getMonth();
    m[k]=(m[k]||0)+d.value;
  });
  let vals = Object.values(m);
  return (std(vals)/(mean(vals)||1))*100;
}

function computeVolatility(values){
  const pct=[];
  for(let i=1;i<values.length;i++){
    let prev = Math.abs(values[i-1]) || 1;
    pct.push(Math.abs((values[i]-values[i-1]) / prev));
  }
  return mean(pct)*100;
}

/* ---------------- FORECAST ---------------- */

function generateForecast(values){
  const window=4;
  let avg = mean(values.slice(-window));
  return [avg*1.02, avg*1.04, avg*1.06].map(v=>Math.round(v));
}

function computeBands(values,forecast){
  const s = std(values);
  return forecast.map(f=>({
    upper: Math.round(f + s),
    lower: Math.round(f - s)
  }));
}

/* ---------------- CHARTS ---------------- */

function destroy(n){ if(charts[n]) charts[n].destroy(); }

function renderCharts(parsed,values,forecast,bands){
  Object.keys(charts).forEach(k=>destroy(k));

  const labels = parsed.map(p=>p.date.toISOString().slice(0,7));
  const fLabels = ["F1","F2","F3"];

  charts.line = new Chart(lineChart,{
    type:"line",
    data:{
      labels:[...labels,...fLabels],
      datasets:[
        {label:"Actual",data:values,borderWidth:2},
        {label:"Forecast",data:Array(values.length).fill(null).concat(forecast),borderDash:[5,5]}
      ]
    }
  });

  charts.band = new Chart(bandChart,{
    type:"line",
    data:{
      labels:fLabels,
      datasets:[
        {label:"Upper Band",data:bands.map(b=>b.upper)},
        {label:"Lower Band",data:bands.map(b=>b.lower)}
      ]
    }
  });

  charts.kpi = new Chart(kpiChart,{
    type:"bar",
    data:{
      labels:["Max","Min","Avg"],
      datasets:[{data:[
        Math.max(...values),
        Math.min(...values),
        Math.round(mean(values))
      ]}]
    }
  });

  /* Product Distribution Pie */
  const seg={};
  parsed.forEach(p=>seg[p.product]=(seg[p.product]||0)+p.value);

  charts.productPie = new Chart(productPie,{
    type:"pie",
    data:{labels:Object.keys(seg),datasets:[{data:Object.values(seg)}]}
  });

  /* Financial Split Pie */
  const revenue = headers["revenue"]!==undefined ? sumCol("revenue") : 0;
  const cost = headers["cost"]!==undefined ? sumCol("cost") : 0;
  const profit = headers["profit"]!==undefined ? sumCol("profit") : Math.max(0,revenue-cost);

  charts.financialPie = new Chart(financialPie,{
    type:"pie",
    data:{
      labels:["Revenue","Cost","Profit"],
      datasets:[{data:[revenue,cost,profit]}]
    }
  });
}

function sumCol(name){
  const idx = headers[name];
  if(idx===undefined) return 0;
  let s=0;
  rawRows.forEach(r=>{
    let v = safeNum(r[idx]);
    if(v!==null) s+=v;
  });
  return Math.round(s);
}

function renderConfidence(){
  destroy("conf");
  charts.conf = new Chart(confidenceChart,{
    type:"line",
    data:{
      labels:confidenceHistory.map((_,i)=>"Run "+(i+1)),
      datasets:[{label:"Confidence Strength",data:confidenceHistory}]
    }
  });
}

/* ---------------- PANELS ---------------- */

function renderInsights(conf,mape,season,vol,growth,status){
  insightPanel.innerHTML = `
    <div class="card">Trend Growth: ${growth.toFixed(1)}%</div>
    <div class="card">Seasonality: ${season.toFixed(1)}%</div>
    <div class="card">Forecast Error Risk: ${mape.toFixed(1)}%</div>
    <div class="card">Validation: ${status}</div>
  `;
}

function renderRisk(conf,mape,season,vol){
  riskPanel.innerHTML = `
    <div class="card">Confidence<div class="value">${conf.toFixed(1)}%</div></div>
    <div class="card">MAPE<div class="value">${mape.toFixed(1)}%</div></div>
    <div class="card">Seasonality<div class="value">${season.toFixed(1)}%</div></div>
    <div class="card">Volatility<div class="value">${vol.toFixed(1)}%</div></div>
  `;
}

function renderScenario(forecast){
  scenarioPanel.innerHTML = `
    <div class="card">Base<div class="value">${forecast.join(", ")}</div></div>
  `;
}

/* ---------------- PDF REPORT ---------------- */

async function exportPDF(){
  const {jsPDF} = window.jspdf;
  const pdf = new jsPDF("p","mm","a4");

  pdf.setFontSize(16);
  pdf.text("PARAGON ANALYTICS REPORT",10,15);
  pdf.setFontSize(10);
  pdf.text("Generated: "+new Date().toLocaleString(),10,22);

  pdf.text("Validation: "+document.querySelector(".badge")?.innerText,10,32);
  pdf.text("This report summarizes forecast performance, stability, and operational intelligence.",10,40);

  pdf.text("Key Insights:",10,55);
  pdf.text("- Forecast reliability based on volatility and data consistency.",10,62);
  pdf.text("- Seasonality patterns indicate cyclical demand behavior.",10,69);
  pdf.text("- Growth trend reflects overall performance direction.",10,76);
  pdf.text("- Validation status determines operational readiness.",10,83);

  pdf.text("Recommendations:",10,98);
  pdf.text("- Use validated forecasts for procurement planning.",10,105);
  pdf.text("- Monitor unstable datasets for missing or inconsistent data.",10,112);
  pdf.text("- Increase dataset size for higher confidence stability.",10,119);

  pdf.save("paragon_report.pdf");
}
</script>
</body>
  </html>
