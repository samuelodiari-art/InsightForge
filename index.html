<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>InsightForge AI</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#22c55e">

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body {
  font-family: system-ui, Arial;
  background:#020617;
  color:white;
  text-align:center;
  padding:15px;
}
h1 { color:#22c55e; }

button {
  padding:14px 22px;
  margin:8px;
  border-radius:10px;
  border:none;
  font-size:16px;
  cursor:pointer;
}
.run { background:#22c55e; color:black; }
.report { background:#f59e0b; color:black; }
.install { background:#0ea5e9; color:black; display:none; }

#output {
  background:#020617;
  padding:12px;
  border-radius:10px;
  margin-top:15px;
  text-align:left;
  font-size:14px;
}

.dashboard {
  background:rgba(255,255,255,0.06);
  padding:12px;
  border-radius:12px;
  margin-top:15px;
  text-align:left;
}

.stat { margin:6px 0; }

canvas { max-width:100%; margin-top:20px; }
</style>
</head>

<body>

<h1>ðŸš€ InsightForge AI</h1>
<p>Upload CSV â†’ Run AI Forecast â†’ Install as App</p>

<input type="file" id="fileInput" accept=".csv"><br><br>

<select id="columnSelect">
  <option value="">Select column...</option>
</select><br><br>

<button class="run" onclick="runAnalysis()">Run AI Analysis</button>
<button class="report" onclick="downloadReport()">Download Report</button>
<button class="install" id="installBtn">Install App</button>

<div id="output">Waiting for CSV...</div>

<canvas id="chart"></canvas>

<div id="dashboard" class="dashboard" style="display:none;">
  <h3>ðŸ“Š Live Insights</h3>
  <div class="stat" id="statAvg"></div>
  <div class="stat" id="statMin"></div>
  <div class="stat" id="statMax"></div>
  <div class="stat" id="statGrowth"></div>
  <div class="stat" id="statForecast"></div>
  <div class="stat" id="statConfidence"></div>
  <div class="stat" id="statAnomaly"></div>
</div>

<script>
let csvRows = [];
let chartInstance = null;
let reportData = null;
let deferredPrompt = null;

// -------------------- PWA INSTALL --------------------
window.addEventListener("beforeinstallprompt", e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById("installBtn").style.display = "inline-block";
});

document.getElementById("installBtn").onclick = async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  deferredPrompt = null;
};

// -------------------- CSV LOAD --------------------
document.getElementById("fileInput").addEventListener("change", loadCSV);

function loadCSV() {
  const file = fileInput.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    const text = e.target.result.trim();
    csvRows = text.split("\n").map(r => r.split(","));
    const headers = csvRows[0];

    columnSelect.innerHTML = '<option value="">Select column...</option>';
    headers.forEach(h => {
      const opt = document.createElement("option");
      opt.value = h.trim();
      opt.textContent = h.trim();
      columnSelect.appendChild(opt);
    });

    output.innerHTML = "âœ… CSV Loaded. Select a column.";
  };
  reader.readAsText(file);
}

// -------------------- CORE ENGINE --------------------
function runAnalysis() {
  const column = columnSelect.value;
  if (!column) return alert("Select a column.");

  const headers = csvRows[0].map(h => h.trim());
  const colIndex = headers.indexOf(column);
  if (colIndex === -1) return alert("Column not found.");

  let labels = [];
  let values = [];

  for (let i = 1; i < csvRows.length; i++) {
    labels.push("Row " + i);
    let raw = (csvRows[i][colIndex] || "").replace(/[^0-9.-]/g,"");
    const num = parseFloat(raw);
    values.push(isNaN(num) ? 0 : num);
  }

  if (values.length < 3) return alert("Need more data.");

  // ---------- Stats ----------
  const avg = values.reduce((a,b)=>a+b,0)/values.length;
  const min = Math.min(...values);
  const max = Math.max(...values);
  const growth = ((values.at(-1)-values[0])/values[0])*100;

// ===== SMART FORECAST ENGINE =====

// Smooth values (moving average)
function smooth(values, window = 3) {
  return values.map((_, i, arr) => {
    const start = Math.max(0, i - window + 1);
    const slice = arr.slice(start, i + 1);
    return slice.reduce((a, b) => a + b, 0) / slice.length;
  });
}

// Weighted linear regression slope
function weightedSlope(values) {
  const n = values.length;
  let sumW = 0, sumWX = 0, sumWY = 0, sumWXY = 0, sumWX2 = 0;

  values.forEach((y, i) => {
    const w = i + 1; // recent data weighted higher
    const x = i;
    sumW += w;
    sumWX += w * x;
    sumWY += w * y;
    sumWXY += w * x * y;
    sumWX2 += w * x * x;
  });

  const numerator = sumW * sumWXY - sumWX * sumWY;
  const denominator = sumW * sumWX2 - sumWX * sumWX;

  return denominator === 0 ? 0 : numerator / denominator;
}

// Generate forecast
function generateForecast(rawValues, steps = 3) {
  if (rawValues.length < 3) {
    const last = rawValues[rawValues.length - 1] || 0;
    return Array(steps).fill(last);
  }

  const smoothed = smooth(rawValues);
  const slope = weightedSlope(smoothed);
  const last = smoothed[smoothed.length - 1];

  const forecasts = [];
  for (let i = 1; i <= steps; i++) {
    let next = last + slope * i;

    // Clamp extreme jumps
    const maxJump = Math.abs(last) * 0.35;
    next = Math.max(last - maxJump, Math.min(last + maxJump, next));

    forecasts.push(Math.round(next));
  }

  return forecasts;
}

// Confidence range
function confidenceBands(values, forecasts) {
  const avg = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / values.length;
  const deviation = Math.sqrt(variance);

  const upper = forecasts.map(v => Math.round(v + deviation));
  const lower = forecasts.map(v => Math.round(v - deviation));

  return { upper, lower };
}

// ===== Run forecast =====
const forecastSteps = 3;
const forecastArray = generateForecast(values, forecastSteps);
const forecast = forecastArray[forecastArray.length - 1];

const bands = confidenceBands(values, forecastArray);
const upper = bands.upper;
const lower = bands.lower;




  // ---------- Anomaly ----------
  let anomalies=[];
  values.forEach((v,i)=>{
    if(v>avg+2*std) anomalies.push(`Row ${i+1} spike`);
    if(v<avg-2*std) anomalies.push(`Row ${i+1} drop`);
  });

  reportData = {
    column, avg, min, max,
    growth: growth.toFixed(1),
    forecast: forecastValues.slice(-forecastSteps),
    confidence: std.toFixed(0),
    anomalies
  };

  updateDashboard(reportData);
  renderChart(forecastLabels, forecastValues, upper, lower, column);
  output.innerHTML = "âœ… AI Analysis completed.";
}

// -------------------- UI --------------------
function updateDashboard(r){
  dashboard.style.display="block";
  statAvg.innerHTML = "ðŸ“Š Average: "+r.avg.toFixed(0);
  statMin.innerHTML = "â¬‡ï¸ Min: "+r.min.toFixed(0);
  statMax.innerHTML = "â¬†ï¸ Max: "+r.max.toFixed(0);
  statGrowth.innerHTML = "ðŸ“ˆ Growth: "+r.growth+"%";
  statForecast.innerHTML = "ðŸ¤– Forecast: "+r.forecast.join(", ");
  statConfidence.innerHTML = "ðŸŽ¯ Confidence Ïƒ: "+r.confidence;
  statAnomaly.innerHTML = "ðŸš¨ Anomalies: "+(r.anomalies.length?r.anomalies.join(", "):"None");
}

function renderChart(labels,data,upper,lower,name){
  const ctx = chart.getContext("2d");
  if(chartInstance) chartInstance.destroy();

  chartInstance = new Chart(ctx,{
    type:"line",
    data:{
      labels,
      datasets:[
        {label:name,data,tension:.3},
        {label:"Upper CI",data:upper,borderDash:[5,5]},
        {label:"Lower CI",data:lower,borderDash:[5,5]}
      ]
    },
    options:{responsive:true}
  });
}

// -------------------- REPORT --------------------
function downloadReport(){
  if(!reportData) return alert("Run analysis first.");

  const text = `
INSIGHTFORGE AI REPORT
--------------------
Column: ${reportData.column}
Average: ${reportData.avg.toFixed(0)}
Min: ${reportData.min.toFixed(0)}
Max: ${reportData.max.toFixed(0)}
Growth: ${reportData.growth}%
Forecast: ${reportData.forecast.join(", ")}
Confidence Ïƒ: ${reportData.confidence}
Anomalies: ${reportData.anomalies.length?reportData.anomalies.join(", "):"None"}
`;

  const blob = new Blob([text],{type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download="insightforge_report.txt";
  a.click();
}
  let deferredPrompt;

window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById("installBtn").style.display = "inline-block";
});

document.getElementById("installBtn").addEventListener("click", async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
});
  // =========================
// Auto-load CSV when selected
// =========================
document.getElementById("fileInput").addEventListener("change", function () {
  const file = this.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = function (e) {
    const text = e.target.result.trim();
    const rows = text.split("\n").map(r => r.split(","));
    const headers = rows[0];

    const dropdown = document.getElementById("columnSelect");
    dropdown.innerHTML = `<option value="">Select column...</option>`;

    headers.forEach(h => {
      const opt = document.createElement("option");
      opt.value = h.trim();
      opt.textContent = h.trim();
      dropdown.appendChild(opt);
    });

    document.getElementById("output").innerHTML =
      "âœ… CSV loaded<br>ðŸ“Š Columns detected: " + headers.join(", ");
  };

  reader.readAsText(file);
});
</script>

</body>
</html>      




    
